# 배송코스 관리 시스템 - 기술 검토서

> **작성일**: 2025-10-18
> **검토 목적**: 배송코스 기능 구현 가능성 및 설계 방안 검토

---

## 📋 요구사항 정리

### 1. 사업장 번호 부여
- 등록된 사업장에 각 번호를 부여

### 2. 배송 코스 생성
- A, B, C, D 등의 코스 만들기
- 각 코스에 사업장 배정

### 3. 역할별 권한
- **배송기사**: 자신의 코스만 조회
- **관리자**: 전체 코스 관리 (생성, 수정, 삭제)

### 4. 배송 추적 및 기록
- 각 사업장 도착 시간 자동 기록
- GPS 기반 이동 경로 추적
- 이력 데이터 저장 및 분석

### 5. 경로 시뮬레이션
- 사업장 간 이동 시간 예측
- 최적 경로 제안

### 6. 시스템 부하 분석
- 성능 영향도 예측

---

## ✅ 구현 가능성 분석

### 현재 시스템 현황

#### 이미 구현된 기능
| 기능 | 현재 상태 | 활용 가능 여부 |
|------|----------|--------------|
| **Site 모델** | ✅ latitude, longitude 존재 | ✅ GPS 좌표 활용 가능 |
| **deliveryRoute 필드** | ✅ String 타입으로 존재 | ✅ 코스명 저장 가능 |
| **sortOrder 필드** | ✅ 존재 | ✅ 방문 순서 관리 가능 |
| **DELIVERY_DRIVER 역할** | ✅ Role enum에 존재 | ✅ 배송기사 권한 분리 가능 |
| **Attendance GPS** | ✅ checkInLat, checkInLng | ✅ 위치 추적 로직 참고 가능 |
| **StaffSite 연결** | ✅ 직원-사업장 매핑 | ✅ 기사-코스 배정 가능 |

#### 신규 개발 필요 사항
- 배송 코스 전용 모델 (DeliveryRoute)
- 배송 기록 모델 (DeliveryLog)
- GPS 실시간 추적 로직
- Kakao/Google Maps API 연동 (거리/시간 계산)

---

## 🗄️ 데이터베이스 설계

### 신규 모델 추가

#### 1. DeliveryRoute (배송 코스)

```prisma
model DeliveryRoute {
  id          String   @id @default(uuid())
  name        String   @unique           // "A코스", "B코스"
  code        String   @unique           // "A", "B", "C"
  division    Division                   // HQ, YEONGNAM
  description String?                    // 코스 설명
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  // Relations
  routeStops      DeliveryRouteStop[]    // 코스 내 사업장 목록
  assignments     DeliveryAssignment[]   // 기사 배정
  deliveryLogs    DeliveryLog[]          // 배송 기록

  @@index([division])
  @@index([isActive])
}
```

#### 2. DeliveryRouteStop (코스 내 사업장 순서)

```prisma
model DeliveryRouteStop {
  id                String   @id @default(uuid())
  routeId           String
  siteId            String
  stopNumber        Int                   // 방문 순서 (1, 2, 3...)
  estimatedArrival  String?               // 예상 도착 시간 "09:30"
  estimatedDuration Int?                  // 예상 소요 시간 (분)
  notes             String?               // 특이사항
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  route    DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  site     Site          @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@unique([routeId, siteId])      // 같은 코스에 중복 사업장 방지
  @@unique([routeId, stopNumber])  // 같은 코스에 중복 순서 방지
  @@index([routeId, stopNumber])
  @@index([siteId])
}
```

#### 3. DeliveryAssignment (기사 배정)

```prisma
model DeliveryAssignment {
  id         String    @id @default(uuid())
  routeId    String
  driverId   String                        // User.id (DELIVERY_DRIVER)
  assignedAt DateTime  @default(now())
  removedAt  DateTime?
  isActive   Boolean   @default(true)

  // Relations
  route  DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  driver User          @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@unique([routeId, driverId])
  @@index([driverId])
  @@index([routeId])
}
```

#### 4. DeliveryLog (배송 기록)

```prisma
model DeliveryLog {
  id              String          @id @default(uuid())
  routeId         String
  siteId          String
  driverId        String
  deliveryDate    DateTime        @db.Date       // 배송 날짜
  stopNumber      Int                            // 방문 순서

  // GPS 및 시간 정보
  arrivedAt       DateTime?                      // 실제 도착 시간
  departedAt      DateTime?                      // 출발 시간
  arrivalLat      Float?                         // 도착 시 GPS
  arrivalLng      Float?
  departureLat    Float?                         // 출발 시 GPS
  departureLng    Float?

  // 배송 상태
  status          DeliveryStatus  @default(PENDING)
  actualDuration  Int?                           // 실제 소요 시간 (분)
  distanceKm      Float?                         // 이동 거리

  // 메모
  note            String?
  issueReported   Boolean         @default(false)
  issueDetail     String?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  route  DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  site   Site          @relation(fields: [siteId], references: [id], onDelete: Cascade)
  driver User          @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@unique([routeId, siteId, deliveryDate])   // 하루에 한 번만 배송
  @@index([deliveryDate])
  @@index([driverId, deliveryDate])
  @@index([routeId, deliveryDate])
  @@index([status])
}

enum DeliveryStatus {
  PENDING      // 대기
  IN_TRANSIT   // 이동 중
  ARRIVED      // 도착
  COMPLETED    // 완료
  DELAYED      // 지연
  ISSUE        // 문제 발생
}
```

#### 5. Site 모델 업데이트

```prisma
model Site {
  // ... 기존 필드

  // 새로 추가
  routeStops   DeliveryRouteStop[]  // 코스 정류장
  deliveryLogs DeliveryLog[]        // 배송 기록
}
```

#### 6. User 모델 업데이트

```prisma
model User {
  // ... 기존 필드

  // 새로 추가
  deliveryAssignments DeliveryAssignment[]  // 배송 기사 배정
  deliveryLogs        DeliveryLog[]         // 배송 기록
}
```

---

## 🔧 기능별 구현 방안

### 1. 사업장 번호 부여

**현재 상황:**
- Site 모델에 `sortOrder` 필드 존재

**구현 방안:**
```typescript
// 코스 내 순서는 DeliveryRouteStop.stopNumber 사용
// 전체 사업장 순서는 기존 Site.sortOrder 활용
```

**예시:**
```
A코스:
  1번: 삼성전자 본사
  2번: LG전자 빌딩
  3번: 현대자동차 사옥

B코스:
  1번: SK하이닉스
  2번: 카카오
  3번: 네이버
```

---

### 2. 배송 코스 생성 및 관리

#### 관리자 기능 (웹 관리자)

**코스 생성 페이지**
```
경로: /delivery-routes
기능:
  - 코스 목록 조회 (Table)
  - 코스 생성 (Modal)
    * 코스명: A코스, B코스
    * 코드: A, B, C
    * 부문: 본사/영남지사
    * 설명: 선택사항
  - 코스 수정/삭제
```

**코스 상세 페이지**
```
경로: /delivery-routes/:id
기능:
  - 사업장 추가/제거 (Transfer 컴포넌트)
  - 방문 순서 조정 (Drag & Drop)
  - 예상 도착 시간 설정
  - 기사 배정
```

**시각화**
```tsx
// 지도에 코스 경로 표시
<KakaoMap>
  {routeStops.map((stop, index) => (
    <Marker
      position={{ lat: stop.site.latitude, lng: stop.site.longitude }}
      label={`${index + 1}`}
    />
  ))}
  <Polyline path={routeStops} />  // 경로 선
</KakaoMap>
```

---

### 3. 배송기사 앱 (모바일)

#### 오늘의 배송 코스 조회

```tsx
// mobile/src/screens/DeliveryRouteScreen.tsx
function DeliveryRouteScreen() {
  const { data: myRoute } = useQuery(['my-route', today],
    () => getMyDeliveryRoute(today)
  );

  return (
    <ScrollView>
      <RouteHeader route={myRoute} />

      {myRoute.stops.map((stop) => (
        <StopCard
          key={stop.id}
          stopNumber={stop.stopNumber}
          siteName={stop.site.name}
          address={stop.site.address}
          estimatedArrival={stop.estimatedArrival}
          status={stop.deliveryLog?.status}
          onCheckIn={() => handleCheckIn(stop)}
          onComplete={() => handleComplete(stop)}
        />
      ))}
    </ScrollView>
  );
}
```

#### 체크인/체크아웃 기능

```tsx
async function handleCheckIn(stop: RouteStop) {
  // 1. GPS 좌표 가져오기
  const location = await getCurrentLocation();

  // 2. 도착 기록
  await createDeliveryLog({
    routeId: stop.routeId,
    siteId: stop.siteId,
    arrivedAt: new Date(),
    arrivalLat: location.latitude,
    arrivalLng: location.longitude,
    status: 'ARRIVED',
  });

  // 3. 알림
  Alert.alert('체크인 완료', `${stop.site.name}에 도착했습니다`);
}
```

---

### 4. GPS 추적 및 기록

#### 실시간 위치 추적 (백그라운드)

```typescript
// mobile/src/services/location-tracking.ts
import * as Location from 'expo-location';
import * as TaskManager from 'expo-task-manager';

const LOCATION_TASK_NAME = 'background-location-task';

// 백그라운드 위치 추적 등록
TaskManager.defineTask(LOCATION_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error(error);
    return;
  }

  const { locations } = data as any;
  const location = locations[0];

  // 서버로 위치 전송
  await sendLocationToServer({
    latitude: location.coords.latitude,
    longitude: location.coords.longitude,
    timestamp: new Date(location.timestamp),
  });
});

// 추적 시작
export async function startLocationTracking() {
  await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
    accuracy: Location.Accuracy.High,
    timeInterval: 30000,  // 30초마다
    distanceInterval: 100, // 100m 이동 시
    foregroundService: {
      notificationTitle: '배송 중',
      notificationBody: '위치가 추적되고 있습니다',
    },
  });
}
```

#### 도착 감지 (Geofencing)

```typescript
// 사업장 반경 100m 이내 진입 시 자동 체크인
import * as Location from 'expo-location';

async function setupGeofencing(stops: RouteStop[]) {
  await Location.startGeofencingAsync('DELIVERY_GEOFENCE',
    stops.map(stop => ({
      identifier: stop.siteId,
      latitude: stop.site.latitude,
      longitude: stop.site.longitude,
      radius: 100, // 100m
      notifyOnEnter: true,
      notifyOnExit: true,
    }))
  );
}

// Geofence 이벤트 처리
TaskManager.defineTask('DELIVERY_GEOFENCE', async ({ data, error }) => {
  const { eventType, region } = data as any;

  if (eventType === Location.GeofencingEventType.Enter) {
    // 사업장 반경 진입 → 자동 체크인 제안
    showCheckInNotification(region.identifier);
  }
});
```

---

### 5. 경로 시뮬레이션 (이동 시간 예측)

#### Kakao Mobility API 연동

```typescript
// backend/src/services/route-optimization.service.ts
import axios from 'axios';

export class RouteOptimizationService {
  private kakaoRestApiKey = process.env.KAKAO_REST_API_KEY;

  /**
   * 두 지점 간 이동 시간 및 거리 계산
   */
  async calculateRoute(
    origin: { lat: number; lng: number },
    destination: { lat: number; lng: number }
  ) {
    const url = 'https://apis-navi.kakaomobility.com/v1/directions';

    const response = await axios.get(url, {
      params: {
        origin: `${origin.lng},${origin.lat}`,
        destination: `${destination.lng},${destination.lat}`,
        priority: 'RECOMMEND', // 추천 경로
      },
      headers: {
        Authorization: `KakaoAK ${this.kakaoRestApiKey}`,
      },
    });

    const route = response.data.routes[0];

    return {
      distanceMeters: route.summary.distance,      // 거리 (m)
      durationSeconds: route.summary.duration,     // 소요 시간 (초)
      distanceKm: route.summary.distance / 1000,
      durationMinutes: Math.ceil(route.summary.duration / 60),
    };
  }

  /**
   * 전체 코스 시뮬레이션
   */
  async simulateRoute(stops: RouteStop[]) {
    const segments = [];
    let totalDistance = 0;
    let totalDuration = 0;
    let currentTime = new Date('2025-01-01 08:00'); // 시작 시간

    for (let i = 0; i < stops.length - 1; i++) {
      const origin = {
        lat: stops[i].site.latitude,
        lng: stops[i].site.longitude
      };
      const destination = {
        lat: stops[i + 1].site.latitude,
        lng: stops[i + 1].site.longitude
      };

      const route = await this.calculateRoute(origin, destination);

      totalDistance += route.distanceKm;
      totalDuration += route.durationMinutes;

      currentTime = new Date(currentTime.getTime() + route.durationMinutes * 60000);

      segments.push({
        from: stops[i].site.name,
        to: stops[i + 1].site.name,
        distance: route.distanceKm,
        duration: route.durationMinutes,
        estimatedArrival: currentTime.toISOString(),
      });
    }

    return {
      totalDistance,
      totalDuration,
      segments,
    };
  }

  /**
   * 경로 최적화 (TSP - Traveling Salesman Problem)
   */
  async optimizeRoute(sites: Site[], startPoint: { lat: number; lng: number }) {
    // 간단한 Nearest Neighbor 알고리즘
    const unvisited = [...sites];
    const optimized: Site[] = [];
    let current = startPoint;

    while (unvisited.length > 0) {
      let nearest = null;
      let minDistance = Infinity;

      for (const site of unvisited) {
        const route = await this.calculateRoute(current, {
          lat: site.latitude,
          lng: site.longitude,
        });

        if (route.distanceKm < minDistance) {
          minDistance = route.distanceKm;
          nearest = site;
        }
      }

      if (nearest) {
        optimized.push(nearest);
        current = { lat: nearest.latitude, lng: nearest.longitude };
        unvisited.splice(unvisited.indexOf(nearest), 1);
      }
    }

    return optimized;
  }
}
```

#### 관리자 시뮬레이션 기능

```tsx
// web/src/pages/delivery-route/RouteSimulationPage.tsx
function RouteSimulationPage() {
  const [simulation, setSimulation] = useState(null);

  async function handleSimulate() {
    const result = await simulateDeliveryRoute(routeId);
    setSimulation(result);
  }

  return (
    <Card>
      <Button onClick={handleSimulate}>경로 시뮬레이션</Button>

      {simulation && (
        <div>
          <Statistic title="총 거리" value={simulation.totalDistance} suffix="km" />
          <Statistic title="총 소요 시간" value={simulation.totalDuration} suffix="분" />

          <Timeline>
            {simulation.segments.map((seg, i) => (
              <Timeline.Item key={i}>
                <strong>{seg.to}</strong>
                <br />
                도착 예정: {seg.estimatedArrival}
                <br />
                소요: {seg.duration}분 ({seg.distance}km)
              </Timeline.Item>
            ))}
          </Timeline>
        </div>
      )}
    </Card>
  );
}
```

---

## 📊 시스템 부하 분석

### 1. 데이터베이스 부하

#### 예상 데이터량 (500개 사업장 기준)

| 테이블 | 레코드 수 | 월간 증가량 | 연간 증가량 |
|--------|----------|-----------|-----------|
| **DeliveryRoute** | 20개 코스 | +2 | +24 |
| **DeliveryRouteStop** | 500개 (코스당 25개) | +50 | +600 |
| **DeliveryAssignment** | 20개 (기사 20명) | +2 | +24 |
| **DeliveryLog** | 10,000개/일 | 300,000 | 3,600,000 |

**연간 DeliveryLog 증가량:**
- 하루 500개 사업장 × 평균 1회 방문 = 500개
- 월 500 × 20일 = 10,000개
- **연 120,000개**

#### 인덱스 최적화

```sql
-- 자주 조회되는 쿼리
SELECT * FROM DeliveryLog
WHERE driverId = ? AND deliveryDate = ?
ORDER BY stopNumber;

-- 인덱스 전략
CREATE INDEX idx_delivery_log_driver_date
ON DeliveryLog(driverId, deliveryDate);

CREATE INDEX idx_delivery_log_route_date
ON DeliveryLog(routeId, deliveryDate);
```

#### 파티셔닝 (1년 후)

```sql
-- 월별 파티셔닝
CREATE TABLE DeliveryLog_2025_01 PARTITION OF DeliveryLog
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE DeliveryLog_2025_02 PARTITION OF DeliveryLog
FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

---

### 2. API 부하

#### 실시간 GPS 추적

**시나리오:**
- 배송기사 20명
- GPS 업데이트 주기: 30초

**API 호출량:**
```
20명 × 2회/분 = 40 req/min = 2,400 req/hour
```

**대역폭:**
```
GPS 데이터 크기: ~100 bytes
40 req/min × 100 bytes = 4KB/min = 240KB/hour = 2MB/day
```

**결론:** 매우 낮은 부하 (무시 가능)

---

#### Kakao Mobility API 호출

**시나리오:**
- 코스 시뮬레이션: 관리자가 하루 10회
- 각 시뮬레이션당 API 호출: 25회 (사업장 25개)

**API 호출량:**
```
10회 × 25 = 250 req/day
```

**Kakao API 무료 한도:**
- 월 100,000건

**결론:** 무료 한도 내 충분

---

### 3. 모바일 앱 배터리 소모

#### 백그라운드 위치 추적

**설정:**
- 업데이트 주기: 30초
- 정확도: High

**예상 배터리 소모:**
- 8시간 배송: ~15-20% (중간 수준)

**최적화 방안:**
- 배송 시작/종료 버튼으로 추적 on/off
- 정지 시 위치 추적 중단
- 거리 기반 업데이트 사용 (100m)

---

### 4. 서버 리소스

#### CPU

**주요 작업:**
- GPS 데이터 처리
- 거리/시간 계산
- 경로 최적화 알고리즘

**예상 사용량:**
- 평균: 5-10%
- 피크: 20-30% (경로 최적화 시)

#### 메모리

**예상 사용량:**
- DeliveryLog 캐싱: ~50MB (최근 7일)
- Route 정보: ~10MB
- 총: ~100MB 추가

#### 네트워크

**일일 트래픽:**
- GPS 업데이트: 2MB
- API 응답: 50MB
- 총: ~60MB/day = 1.8GB/month

**결론:** 현재 서버(e2-small) 충분

---

## 💰 비용 분석

### 1. API 비용

| 항목 | 사용량 | 비용 |
|------|--------|------|
| **Kakao Mobility API** | 월 7,500건 | 무료 (100,000건 한도) |
| **GPS 데이터 전송** | 월 1.8GB | 포함 (GCP VM 트래픽) |

**총 추가 비용:** $0

---

### 2. 개발 비용

| 항목 | 예상 공수 | 설명 |
|------|----------|------|
| **DB 스키마 추가** | 1일 | Prisma 모델 4개 추가 |
| **백엔드 API** | 5일 | CRUD + 시뮬레이션 + GPS 처리 |
| **웹 관리자** | 7일 | 코스 관리 페이지 3개 |
| **모바일 앱** | 10일 | GPS 추적 + 배송 화면 4개 |
| **테스트 및 버그 수정** | 3일 | 통합 테스트 |
| **총 개발 기간** | **26일** (약 1개월) | |

---

## ⚠️ 주의사항 및 제약

### 1. GPS 정확도

**문제:**
- 실내/지하: GPS 정확도 저하
- 고층 빌딩: 신호 반사

**해결:**
- Wi-Fi/셀룰러 위치 보조
- 수동 체크인 옵션 제공

---

### 2. 배터리 소모

**문제:**
- 백그라운드 GPS 추적 시 배터리 소모

**해결:**
- 배송 시작/종료 명확히
- 움직임 감지 후 추적 활성화
- 정지 시 추적 일시 중지

---

### 3. 네트워크 연결

**문제:**
- 오프라인 환경에서 데이터 전송 불가

**해결:**
- 로컬 DB에 데이터 저장 (SQLite)
- 네트워크 복구 시 자동 동기화

---

### 4. 개인정보 보호

**문제:**
- 기사 위치 추적 → 개인정보 이슈

**해결:**
- 배송 시간에만 추적
- 명확한 동의 절차
- 위치 데이터 암호화 저장
- 30일 후 자동 삭제

---

## 🎯 구현 우선순위

### Phase 1: 기본 코스 관리 (2주)

- [ ] DB 스키마 추가
- [ ] 코스 CRUD API
- [ ] 웹 관리자: 코스 목록/생성/수정
- [ ] 사업장 배정 및 순서 관리

### Phase 2: 모바일 배송 기능 (2주)

- [ ] 모바일: 오늘의 코스 조회
- [ ] 수동 체크인/체크아웃
- [ ] 배송 기록 저장
- [ ] 관리자: 배송 기록 조회

### Phase 3: GPS 자동 추적 (1주)

- [ ] 백그라운드 위치 추적
- [ ] Geofencing 자동 체크인
- [ ] 실시간 위치 모니터링 (관리자)

### Phase 4: 경로 최적화 (1주)

- [ ] Kakao Mobility API 연동
- [ ] 경로 시뮬레이션
- [ ] 최적 경로 제안

---

## 📝 결론

### ✅ 구현 가능

**이유:**
1. **기존 인프라 활용 가능**
   - GPS 좌표 (latitude, longitude)
   - DELIVERY_DRIVER 역할
   - Attendance GPS 로직 재사용

2. **외부 API 활용 가능**
   - Kakao Mobility API (무료)
   - Expo Location (React Native)

3. **시스템 부하 낮음**
   - 추가 서버 불필요
   - 현재 e2-small VM 충분
   - 무료 API 한도 내

4. **개발 기간 적정**
   - 1개월 내 완성 가능
   - 단계별 배포 가능

### 💡 권장사항

1. **Phase 1부터 순차 개발**
   - 기본 코스 관리 먼저 구현
   - 사용자 피드백 수집
   - 점진적 기능 추가

2. **MVP (최소 기능 제품) 먼저**
   - 수동 체크인만으로 시작
   - GPS 자동 추적은 나중에 추가

3. **실사용 데이터 수집**
   - 실제 배송 기록 분석
   - 경로 최적화 개선

### 🚀 다음 단계

1. **요구사항 최종 확인**
   - 우선순위 결정
   - MVP 범위 정의

2. **DB 스키마 승인**
   - Prisma 모델 검토
   - 마이그레이션 계획

3. **개발 시작**
   - Phase 1 착수

---

**작성자:** Claude Code Assistant
**검토 완료일:** 2025-10-18
