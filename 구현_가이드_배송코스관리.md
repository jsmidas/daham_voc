# 배송코스 관리 시스템 - 구현 가이드

> **작성일**: 2025-10-19
> **목적**: 배송코스 관리 기능을 단계별로 구현하기 위한 상세 가이드
> **예상 기간**: 26일 (약 1개월)

---

## 📋 목차

1. [프로젝트 개요](#1-프로젝트-개요)
2. [Phase 1: 기본 코스 관리 (2주)](#2-phase-1-기본-코스-관리)
3. [Phase 2: 모바일 배송 기능 (2주)](#3-phase-2-모바일-배송-기능)
4. [Phase 3: GPS 자동 추적 (1주)](#4-phase-3-gps-자동-추적)
5. [Phase 4: 경로 최적화 (1주)](#5-phase-4-경로-최적화)
6. [테스트 계획](#6-테스트-계획)
7. [배포 체크리스트](#7-배포-체크리스트)

---

## 1. 프로젝트 개요

### 1.1 요구사항 요약

| 번호 | 요구사항 | 우선순위 |
|------|---------|---------|
| 1 | 사업장에 번호 부여 및 코스별 순서 관리 | 높음 |
| 2 | A, B, C, D 등 배송 코스 생성 | 높음 |
| 3 | 배송기사별 코스 배정 및 조회 | 높음 |
| 4 | GPS 기반 도착/출발 시간 자동 기록 | 중간 |
| 5 | 사업장 간 이동 시간 시뮬레이션 | 중간 |
| 6 | 시스템 성능 모니터링 | 낮음 |

### 1.2 기술 스택

**백엔드:**
- TypeScript + Express.js
- Prisma ORM
- PostgreSQL
- Kakao Mobility API

**프론트엔드 (웹 관리자):**
- React + TypeScript
- Ant Design
- Kakao Map SDK
- React Query

**모바일:**
- React Native (Expo)
- Expo Location
- Expo Task Manager
- React Navigation

### 1.3 데이터베이스 구조 (신규 모델)

```prisma
// DeliveryRoute: 배송 코스
// DeliveryRouteStop: 코스 내 사업장 순서
// DeliveryAssignment: 기사-코스 배정
// DeliveryLog: 배송 기록
```

---

## 2. Phase 1: 기본 코스 관리

**기간**: 10일
**목표**: 웹 관리자에서 배송 코스를 생성하고 사업장을 배정

### 2.1 데이터베이스 스키마 추가

#### Step 1-1: Prisma Schema 업데이트

**파일**: `backend/prisma/schema.prisma`

```prisma
// ==================== 배송 코스 관리 ====================

// 배송 코스 (A코스, B코스 등)
model DeliveryRoute {
  id          String   @id @default(uuid())
  name        String   @unique           // "A코스", "B코스"
  code        String   @unique           // "A", "B", "C"
  division    Division                   // HQ, YEONGNAM
  description String?                    // 코스 설명
  color       String   @default("#1890ff") // 코스 색상 (지도 표시용)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  // Relations
  routeStops      DeliveryRouteStop[]    // 코스 내 사업장 목록
  assignments     DeliveryAssignment[]   // 기사 배정
  deliveryLogs    DeliveryLog[]          // 배송 기록

  @@index([division])
  @@index([isActive])
  @@map("delivery_routes")
}

// 코스 내 사업장 순서
model DeliveryRouteStop {
  id                String   @id @default(uuid())
  routeId           String
  siteId            String
  stopNumber        Int                   // 방문 순서 (1, 2, 3...)
  estimatedArrival  String?               // 예상 도착 시간 "09:30"
  estimatedDuration Int?                  // 예상 소요 시간 (분)
  notes             String?               // 특이사항
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  route    DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  site     Site          @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@unique([routeId, siteId])      // 같은 코스에 중복 사업장 방지
  @@unique([routeId, stopNumber])  // 같은 코스에 중복 순서 방지
  @@index([routeId, stopNumber])
  @@index([siteId])
  @@map("delivery_route_stops")
}

// 기사-코스 배정
model DeliveryAssignment {
  id         String    @id @default(uuid())
  routeId    String
  driverId   String                        // User.id (DELIVERY_DRIVER)
  assignedAt DateTime  @default(now())
  removedAt  DateTime?
  isActive   Boolean   @default(true)

  // Relations
  route  DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  driver User          @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@unique([routeId, driverId])
  @@index([driverId])
  @@index([routeId])
  @@map("delivery_assignments")
}

// 배송 기록
model DeliveryLog {
  id              String          @id @default(uuid())
  routeId         String
  siteId          String
  driverId        String
  deliveryDate    DateTime        @db.Date       // 배송 날짜
  stopNumber      Int                            // 방문 순서

  // GPS 및 시간 정보
  arrivedAt       DateTime?                      // 실제 도착 시간
  departedAt      DateTime?                      // 출발 시간
  arrivalLat      Float?                         // 도착 시 GPS
  arrivalLng      Float?
  departureLat    Float?                         // 출발 시 GPS
  departureLng    Float?

  // 배송 상태
  status          DeliveryStatus  @default(PENDING)
  actualDuration  Int?                           // 실제 소요 시간 (분)
  distanceKm      Float?                         // 이동 거리

  // 메모
  note            String?
  issueReported   Boolean         @default(false)
  issueDetail     String?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  route  DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  site   Site          @relation(fields: [siteId], references: [id], onDelete: Cascade)
  driver User          @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@unique([routeId, siteId, deliveryDate])   // 하루에 한 번만 배송
  @@index([deliveryDate])
  @@index([driverId, deliveryDate])
  @@index([routeId, deliveryDate])
  @@index([status])
  @@map("delivery_logs")
}

enum DeliveryStatus {
  PENDING      // 대기
  IN_TRANSIT   // 이동 중
  ARRIVED      // 도착
  COMPLETED    // 완료
  DELAYED      // 지연
  ISSUE        // 문제 발생
}

// Site 모델에 추가
model Site {
  // ... 기존 필드

  // 새로 추가
  routeStops   DeliveryRouteStop[]  // 코스 정류장
  deliveryLogs DeliveryLog[]        // 배송 기록
}

// User 모델에 추가
model User {
  // ... 기존 필드

  // 새로 추가
  deliveryAssignments DeliveryAssignment[]  // 배송 기사 배정
  deliveryLogs        DeliveryLog[]         // 배송 기록
}
```

#### Step 1-2: 마이그레이션 생성 및 적용

```bash
# 로컬 개발 환경에서
cd backend

# 마이그레이션 생성
npx prisma migrate dev --name add_delivery_route_system

# Prisma Client 재생성
npx prisma generate

# Git Commit
git add prisma/
git commit -m "feat: Add delivery route management database schema

- Add DeliveryRoute, DeliveryRouteStop, DeliveryAssignment, DeliveryLog models
- Add DeliveryStatus enum
- Update Site and User models with delivery relations"

git push
```

#### Step 1-3: 프로덕션 배포

```bash
ssh root@165.246.44.4
cd ~/daham_voc

# 백업 먼저!
pg_dump -U daham_user daham_voc > ~/backups/before_delivery_routes_$(date +%Y%m%d).sql

# 코드 업데이트
git pull

# 마이그레이션 적용
cd backend
npx prisma migrate deploy
npx prisma generate

# 재시작
npm run build
pm2 restart daham-voc-api

# 확인
pm2 logs daham-voc-api --lines 20
```

---

### 2.2 백엔드 API 구현

#### Step 2-1: Types 정의

**파일**: `backend/src/types/delivery-route.types.ts` (신규 생성)

```typescript
import { DeliveryStatus } from '@prisma/client';

/**
 * 배송 코스 생성 요청
 */
export interface CreateDeliveryRouteDto {
  name: string;           // "A코스"
  code: string;           // "A"
  division: 'HQ' | 'YEONGNAM';
  description?: string;
  color?: string;
}

/**
 * 배송 코스 업데이트 요청
 */
export interface UpdateDeliveryRouteDto {
  name?: string;
  description?: string;
  color?: string;
  isActive?: boolean;
}

/**
 * 코스에 사업장 추가 요청
 */
export interface AddSiteToRouteDto {
  siteId: string;
  stopNumber: number;
  estimatedArrival?: string;  // "09:30"
  estimatedDuration?: number;
  notes?: string;
}

/**
 * 코스 사업장 순서 업데이트
 */
export interface UpdateRouteStopsDto {
  stops: Array<{
    id: string;
    stopNumber: number;
  }>;
}

/**
 * 기사 배정 요청
 */
export interface AssignDriverDto {
  routeId: string;
  driverIds: string[];
}

/**
 * 배송 기록 생성
 */
export interface CreateDeliveryLogDto {
  routeId: string;
  siteId: string;
  stopNumber: number;
  arrivedAt?: Date;
  arrivalLat?: number;
  arrivalLng?: number;
  status: DeliveryStatus;
  note?: string;
}

/**
 * 배송 코스 응답
 */
export interface DeliveryRouteResponse {
  id: string;
  name: string;
  code: string;
  division: string;
  description?: string;
  color: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  stopsCount: number;
  assignedDrivers: Array<{
    id: string;
    name: string;
    phone: string;
  }>;
}

/**
 * 코스 상세 (사업장 포함)
 */
export interface DeliveryRouteDetailResponse extends DeliveryRouteResponse {
  stops: Array<{
    id: string;
    stopNumber: number;
    estimatedArrival?: string;
    estimatedDuration?: number;
    notes?: string;
    site: {
      id: string;
      name: string;
      address: string;
      latitude: number;
      longitude: number;
      type: string;
    };
  }>;
}
```

#### Step 2-2: Validators

**파일**: `backend/src/validators/delivery-route.validator.ts` (신규 생성)

```typescript
import Joi from 'joi';

/**
 * 배송 코스 생성 검증
 */
export const createDeliveryRouteSchema = Joi.object({
  name: Joi.string().min(2).max(50).required().messages({
    'string.min': '코스 이름은 최소 2자 이상이어야 합니다',
    'string.max': '코스 이름은 최대 50자까지 입력 가능합니다',
    'any.required': '코스 이름은 필수 항목입니다',
  }),
  code: Joi.string().min(1).max(10).required().messages({
    'string.min': '코스 코드는 최소 1자 이상이어야 합니다',
    'string.max': '코스 코드는 최대 10자까지 입력 가능합니다',
    'any.required': '코스 코드는 필수 항목입니다',
  }),
  division: Joi.string().valid('HQ', 'YEONGNAM').required().messages({
    'any.only': '유효한 부문을 선택해주세요 (본사/영남지사)',
    'any.required': '부문은 필수 항목입니다',
  }),
  description: Joi.string().max(500).optional().allow('').messages({
    'string.max': '설명은 최대 500자까지 입력 가능합니다',
  }),
  color: Joi.string().pattern(/^#[0-9A-Fa-f]{6}$/).optional().messages({
    'string.pattern.base': '올바른 색상 코드를 입력해주세요 (예: #1890ff)',
  }),
});

/**
 * 배송 코스 수정 검증
 */
export const updateDeliveryRouteSchema = Joi.object({
  name: Joi.string().min(2).max(50).optional(),
  description: Joi.string().max(500).optional().allow(''),
  color: Joi.string().pattern(/^#[0-9A-Fa-f]{6}$/).optional(),
  isActive: Joi.boolean().optional(),
});

/**
 * 코스에 사업장 추가 검증
 */
export const addSiteToRouteSchema = Joi.object({
  siteId: Joi.string().uuid().required().messages({
    'string.uuid': '유효한 사업장 ID를 입력해주세요',
    'any.required': '사업장 ID는 필수 항목입니다',
  }),
  stopNumber: Joi.number().min(1).required().messages({
    'number.min': '방문 순서는 1 이상이어야 합니다',
    'any.required': '방문 순서는 필수 항목입니다',
  }),
  estimatedArrival: Joi.string().pattern(/^([01]\d|2[0-3]):([0-5]\d)$/).optional().messages({
    'string.pattern.base': '올바른 시간 형식을 입력해주세요 (예: 09:30)',
  }),
  estimatedDuration: Joi.number().min(0).optional().messages({
    'number.min': '예상 소요 시간은 0 이상이어야 합니다',
  }),
  notes: Joi.string().max(500).optional().allow(''),
});

/**
 * 코스 사업장 순서 업데이트 검증
 */
export const updateRouteStopsSchema = Joi.object({
  stops: Joi.array()
    .items(
      Joi.object({
        id: Joi.string().uuid().required(),
        stopNumber: Joi.number().min(1).required(),
      })
    )
    .min(1)
    .required()
    .messages({
      'array.min': '최소 1개 이상의 정류장이 필요합니다',
      'any.required': '정류장 목록은 필수 항목입니다',
    }),
});

/**
 * 기사 배정 검증
 */
export const assignDriverSchema = Joi.object({
  routeId: Joi.string().uuid().required(),
  driverIds: Joi.array().items(Joi.string().uuid()).min(1).required().messages({
    'array.min': '최소 1명 이상의 기사를 배정해야 합니다',
  }),
});

/**
 * 배송 기록 생성 검증
 */
export const createDeliveryLogSchema = Joi.object({
  routeId: Joi.string().uuid().required(),
  siteId: Joi.string().uuid().required(),
  stopNumber: Joi.number().min(1).required(),
  arrivedAt: Joi.date().iso().optional(),
  arrivalLat: Joi.number().min(-90).max(90).optional(),
  arrivalLng: Joi.number().min(-180).max(180).optional(),
  status: Joi.string()
    .valid('PENDING', 'IN_TRANSIT', 'ARRIVED', 'COMPLETED', 'DELAYED', 'ISSUE')
    .required(),
  note: Joi.string().max(500).optional().allow(''),
});

/**
 * 쿼리 파라미터 검증
 */
export const getDeliveryRoutesQuerySchema = Joi.object({
  division: Joi.string().valid('HQ', 'YEONGNAM').optional(),
  isActive: Joi.boolean().optional(),
  search: Joi.string().max(100).optional(),
});
```

#### Step 2-3: Service Layer

**파일**: `backend/src/services/delivery-route.service.ts` (신규 생성)

```typescript
import { PrismaClient, Prisma } from '@prisma/client';
import {
  CreateDeliveryRouteDto,
  UpdateDeliveryRouteDto,
  AddSiteToRouteDto,
  UpdateRouteStopsDto,
  AssignDriverDto,
  DeliveryRouteResponse,
  DeliveryRouteDetailResponse,
} from '../types/delivery-route.types';

const prisma = new PrismaClient();

export class DeliveryRouteService {
  /**
   * 배송 코스 목록 조회
   */
  async getDeliveryRoutes(filters: {
    division?: 'HQ' | 'YEONGNAM';
    isActive?: boolean;
    search?: string;
  }): Promise<DeliveryRouteResponse[]> {
    const where: Prisma.DeliveryRouteWhereInput = {
      deletedAt: null,
    };

    if (filters.division) {
      where.division = filters.division;
    }

    if (filters.isActive !== undefined) {
      where.isActive = filters.isActive;
    }

    if (filters.search) {
      where.OR = [
        { name: { contains: filters.search, mode: 'insensitive' } },
        { code: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    const routes = await prisma.deliveryRoute.findMany({
      where,
      include: {
        routeStops: {
          where: { isActive: true },
        },
        assignments: {
          where: { isActive: true },
          include: {
            driver: {
              select: {
                id: true,
                name: true,
                phone: true,
              },
            },
          },
        },
      },
      orderBy: [{ division: 'asc' }, { code: 'asc' }],
    });

    return routes.map((route) => ({
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: route.routeStops.length,
      assignedDrivers: route.assignments.map((a) => a.driver),
    }));
  }

  /**
   * 배송 코스 상세 조회
   */
  async getDeliveryRouteById(id: string): Promise<DeliveryRouteDetailResponse> {
    const route = await prisma.deliveryRoute.findUnique({
      where: { id },
      include: {
        routeStops: {
          where: { isActive: true },
          include: {
            site: {
              select: {
                id: true,
                name: true,
                address: true,
                latitude: true,
                longitude: true,
                type: true,
              },
            },
          },
          orderBy: { stopNumber: 'asc' },
        },
        assignments: {
          where: { isActive: true },
          include: {
            driver: {
              select: {
                id: true,
                name: true,
                phone: true,
              },
            },
          },
        },
      },
    });

    if (!route || route.deletedAt) {
      throw new Error('배송 코스를 찾을 수 없습니다');
    }

    return {
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: route.routeStops.length,
      assignedDrivers: route.assignments.map((a) => a.driver),
      stops: route.routeStops.map((stop) => ({
        id: stop.id,
        stopNumber: stop.stopNumber,
        estimatedArrival: stop.estimatedArrival || undefined,
        estimatedDuration: stop.estimatedDuration || undefined,
        notes: stop.notes || undefined,
        site: stop.site,
      })),
    };
  }

  /**
   * 배송 코스 생성
   */
  async createDeliveryRoute(data: CreateDeliveryRouteDto): Promise<DeliveryRouteResponse> {
    // 중복 검사
    const existingRoute = await prisma.deliveryRoute.findFirst({
      where: {
        OR: [{ name: data.name }, { code: data.code }],
        deletedAt: null,
      },
    });

    if (existingRoute) {
      throw new Error('이미 존재하는 코스명 또는 코드입니다');
    }

    const route = await prisma.deliveryRoute.create({
      data: {
        name: data.name,
        code: data.code,
        division: data.division,
        description: data.description,
        color: data.color || '#1890ff',
      },
      include: {
        routeStops: true,
        assignments: {
          include: {
            driver: {
              select: { id: true, name: true, phone: true },
            },
          },
        },
      },
    });

    return {
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: 0,
      assignedDrivers: [],
    };
  }

  /**
   * 배송 코스 수정
   */
  async updateDeliveryRoute(
    id: string,
    data: UpdateDeliveryRouteDto
  ): Promise<DeliveryRouteResponse> {
    const route = await prisma.deliveryRoute.update({
      where: { id },
      data,
      include: {
        routeStops: {
          where: { isActive: true },
        },
        assignments: {
          where: { isActive: true },
          include: {
            driver: {
              select: { id: true, name: true, phone: true },
            },
          },
        },
      },
    });

    return {
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: route.routeStops.length,
      assignedDrivers: route.assignments.map((a) => a.driver),
    };
  }

  /**
   * 배송 코스 삭제 (소프트 삭제)
   */
  async deleteDeliveryRoute(id: string): Promise<void> {
    await prisma.deliveryRoute.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        isActive: false,
      },
    });
  }

  /**
   * 코스에 사업장 추가
   */
  async addSiteToRoute(routeId: string, data: AddSiteToRouteDto): Promise<void> {
    // 코스 존재 확인
    const route = await prisma.deliveryRoute.findUnique({
      where: { id: routeId },
    });

    if (!route || route.deletedAt) {
      throw new Error('배송 코스를 찾을 수 없습니다');
    }

    // 사업장 존재 확인
    const site = await prisma.site.findUnique({
      where: { id: data.siteId },
    });

    if (!site || site.deletedAt) {
      throw new Error('사업장을 찾을 수 없습니다');
    }

    // 중복 확인
    const existing = await prisma.deliveryRouteStop.findUnique({
      where: {
        routeId_siteId: {
          routeId,
          siteId: data.siteId,
        },
      },
    });

    if (existing) {
      throw new Error('이미 해당 코스에 등록된 사업장입니다');
    }

    // 순서 중복 확인
    const stopNumberExists = await prisma.deliveryRouteStop.findUnique({
      where: {
        routeId_stopNumber: {
          routeId,
          stopNumber: data.stopNumber,
        },
      },
    });

    if (stopNumberExists) {
      throw new Error('이미 사용 중인 순서 번호입니다');
    }

    await prisma.deliveryRouteStop.create({
      data: {
        routeId,
        siteId: data.siteId,
        stopNumber: data.stopNumber,
        estimatedArrival: data.estimatedArrival,
        estimatedDuration: data.estimatedDuration,
        notes: data.notes,
      },
    });
  }

  /**
   * 코스에서 사업장 제거
   */
  async removeSiteFromRoute(routeId: string, siteId: string): Promise<void> {
    await prisma.deliveryRouteStop.update({
      where: {
        routeId_siteId: {
          routeId,
          siteId,
        },
      },
      data: {
        isActive: false,
      },
    });
  }

  /**
   * 코스 사업장 순서 일괄 업데이트
   */
  async updateRouteStops(routeId: string, data: UpdateRouteStopsDto): Promise<void> {
    // 트랜잭션으로 일괄 업데이트
    await prisma.$transaction(
      data.stops.map((stop) =>
        prisma.deliveryRouteStop.update({
          where: { id: stop.id },
          data: { stopNumber: stop.stopNumber },
        })
      )
    );
  }

  /**
   * 기사 배정
   */
  async assignDrivers(data: AssignDriverDto): Promise<void> {
    const { routeId, driverIds } = data;

    // 기존 배정 비활성화
    await prisma.deliveryAssignment.updateMany({
      where: {
        routeId,
        isActive: true,
      },
      data: {
        isActive: false,
        removedAt: new Date(),
      },
    });

    // 새 배정 생성
    await prisma.deliveryAssignment.createMany({
      data: driverIds.map((driverId) => ({
        routeId,
        driverId,
      })),
      skipDuplicates: true,
    });
  }

  /**
   * 배송기사의 배정된 코스 조회
   */
  async getDriverRoutes(driverId: string): Promise<DeliveryRouteDetailResponse[]> {
    const assignments = await prisma.deliveryAssignment.findMany({
      where: {
        driverId,
        isActive: true,
      },
      include: {
        route: {
          include: {
            routeStops: {
              where: { isActive: true },
              include: {
                site: {
                  select: {
                    id: true,
                    name: true,
                    address: true,
                    latitude: true,
                    longitude: true,
                    type: true,
                  },
                },
              },
              orderBy: { stopNumber: 'asc' },
            },
            assignments: {
              where: { isActive: true },
              include: {
                driver: {
                  select: { id: true, name: true, phone: true },
                },
              },
            },
          },
        },
      },
    });

    return assignments.map((assignment) => {
      const route = assignment.route;
      return {
        id: route.id,
        name: route.name,
        code: route.code,
        division: route.division,
        description: route.description || undefined,
        color: route.color,
        isActive: route.isActive,
        createdAt: route.createdAt,
        updatedAt: route.updatedAt,
        stopsCount: route.routeStops.length,
        assignedDrivers: route.assignments.map((a) => a.driver),
        stops: route.routeStops.map((stop) => ({
          id: stop.id,
          stopNumber: stop.stopNumber,
          estimatedArrival: stop.estimatedArrival || undefined,
          estimatedDuration: stop.estimatedDuration || undefined,
          notes: stop.notes || undefined,
          site: stop.site,
        })),
      };
    });
  }
}
```

#### Step 2-4: Controller

**파일**: `backend/src/controllers/delivery-route.controller.ts` (신규 생성)

```typescript
import { Request, Response, NextFunction } from 'express';
import { DeliveryRouteService } from '../services/delivery-route.service';

const deliveryRouteService = new DeliveryRouteService();

/**
 * GET /api/v1/delivery-routes
 * 배송 코스 목록 조회
 */
export async function getDeliveryRoutes(req: Request, res: Response, next: NextFunction) {
  try {
    const { division, isActive, search } = req.query;

    const routes = await deliveryRouteService.getDeliveryRoutes({
      division: division as 'HQ' | 'YEONGNAM' | undefined,
      isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined,
      search: search as string | undefined,
    });

    res.json({
      success: true,
      data: routes,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-routes/:id
 * 배송 코스 상세 조회
 */
export async function getDeliveryRouteById(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const route = await deliveryRouteService.getDeliveryRouteById(id);

    res.json({
      success: true,
      data: route,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes
 * 배송 코스 생성
 */
export async function createDeliveryRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const route = await deliveryRouteService.createDeliveryRoute(req.body);

    res.status(201).json({
      success: true,
      data: route,
      message: '배송 코스가 생성되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * PATCH /api/v1/delivery-routes/:id
 * 배송 코스 수정
 */
export async function updateDeliveryRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const route = await deliveryRouteService.updateDeliveryRoute(id, req.body);

    res.json({
      success: true,
      data: route,
      message: '배송 코스가 수정되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * DELETE /api/v1/delivery-routes/:id
 * 배송 코스 삭제
 */
export async function deleteDeliveryRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.deleteDeliveryRoute(id);

    res.json({
      success: true,
      message: '배송 코스가 삭제되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes/:id/stops
 * 코스에 사업장 추가
 */
export async function addSiteToRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.addSiteToRoute(id, req.body);

    res.status(201).json({
      success: true,
      message: '사업장이 코스에 추가되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * DELETE /api/v1/delivery-routes/:routeId/stops/:siteId
 * 코스에서 사업장 제거
 */
export async function removeSiteFromRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { routeId, siteId } = req.params;
    await deliveryRouteService.removeSiteFromRoute(routeId, siteId);

    res.json({
      success: true,
      message: '사업장이 코스에서 제거되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * PUT /api/v1/delivery-routes/:id/stops/reorder
 * 코스 사업장 순서 변경
 */
export async function updateRouteStops(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.updateRouteStops(id, req.body);

    res.json({
      success: true,
      message: '사업장 순서가 변경되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes/:id/assign-drivers
 * 기사 배정
 */
export async function assignDrivers(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.assignDrivers({
      routeId: id,
      driverIds: req.body.driverIds,
    });

    res.json({
      success: true,
      message: '기사가 배정되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-routes/my-routes
 * 내 배송 코스 조회 (배송기사용)
 */
export async function getMyRoutes(req: Request, res: Response, next: NextFunction) {
  try {
    const userId = req.user?.id; // JWT에서 추출

    if (!userId) {
      return res.status(401).json({
        success: false,
        message: '인증이 필요합니다',
      });
    }

    const routes = await deliveryRouteService.getDriverRoutes(userId);

    res.json({
      success: true,
      data: routes,
    });
  } catch (error) {
    next(error);
  }
}
```

#### Step 2-5: Routes

**파일**: `backend/src/routes/delivery-route.routes.ts` (신규 생성)

```typescript
import { Router } from 'express';
import * as deliveryRouteController from '../controllers/delivery-route.controller';
import { authenticate } from '../middleware/auth.middleware';
import { authorize } from '../middleware/role.middleware';
import { validate } from '../middleware/validation.middleware';
import {
  createDeliveryRouteSchema,
  updateDeliveryRouteSchema,
  addSiteToRouteSchema,
  updateRouteStopsSchema,
  assignDriverSchema,
  getDeliveryRoutesQuerySchema,
} from '../validators/delivery-route.validator';

const router = Router();

// 모든 라우트는 인증 필요
router.use(authenticate);

/**
 * GET /api/v1/delivery-routes
 * 배송 코스 목록 조회
 * 권한: DELIVERY_DRIVER, MANAGER, ADMIN, SUPER_ADMIN
 */
router.get(
  '/',
  validate({ query: getDeliveryRoutesQuerySchema }),
  deliveryRouteController.getDeliveryRoutes
);

/**
 * GET /api/v1/delivery-routes/my-routes
 * 내 배송 코스 조회 (배송기사용)
 * 권한: DELIVERY_DRIVER
 */
router.get(
  '/my-routes',
  authorize(['DELIVERY_DRIVER']),
  deliveryRouteController.getMyRoutes
);

/**
 * GET /api/v1/delivery-routes/:id
 * 배송 코스 상세 조회
 */
router.get('/:id', deliveryRouteController.getDeliveryRouteById);

/**
 * POST /api/v1/delivery-routes
 * 배송 코스 생성
 * 권한: MANAGER, ADMIN, SUPER_ADMIN
 */
router.post(
  '/',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: createDeliveryRouteSchema }),
  deliveryRouteController.createDeliveryRoute
);

/**
 * PATCH /api/v1/delivery-routes/:id
 * 배송 코스 수정
 */
router.patch(
  '/:id',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: updateDeliveryRouteSchema }),
  deliveryRouteController.updateDeliveryRoute
);

/**
 * DELETE /api/v1/delivery-routes/:id
 * 배송 코스 삭제
 */
router.delete(
  '/:id',
  authorize(['ADMIN', 'SUPER_ADMIN']),
  deliveryRouteController.deleteDeliveryRoute
);

/**
 * POST /api/v1/delivery-routes/:id/stops
 * 코스에 사업장 추가
 */
router.post(
  '/:id/stops',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: addSiteToRouteSchema }),
  deliveryRouteController.addSiteToRoute
);

/**
 * DELETE /api/v1/delivery-routes/:routeId/stops/:siteId
 * 코스에서 사업장 제거
 */
router.delete(
  '/:routeId/stops/:siteId',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  deliveryRouteController.removeSiteFromRoute
);

/**
 * PUT /api/v1/delivery-routes/:id/stops/reorder
 * 코스 사업장 순서 변경
 */
router.put(
  '/:id/stops/reorder',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: updateRouteStopsSchema }),
  deliveryRouteController.updateRouteStops
);

/**
 * POST /api/v1/delivery-routes/:id/assign-drivers
 * 기사 배정
 */
router.post(
  '/:id/assign-drivers',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  deliveryRouteController.assignDrivers
);

export default router;
```

#### Step 2-6: 메인 라우터 등록

**파일**: `backend/src/routes/index.ts` (수정)

```typescript
import deliveryRouteRoutes from './delivery-route.routes';

// ... 기존 코드

// 라우트 등록
app.use('/api/v1/delivery-routes', deliveryRouteRoutes);
```

#### Step 2-7: 백엔드 테스트

```bash
# 로컬 백엔드 실행
cd backend
npm run dev:clean

# 다른 터미널에서 API 테스트
# 1. 로그인 (토큰 받기)
curl -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"phone":"01012345678","password":"1234"}'

# TOKEN 저장
TOKEN="eyJhbGc..."

# 2. 배송 코스 생성
curl -X POST http://localhost:3000/api/v1/delivery-routes \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "name": "A코스",
    "code": "A",
    "division": "HQ",
    "description": "본사 오전 배송 코스",
    "color": "#1890ff"
  }'

# 3. 코스 목록 조회
curl http://localhost:3000/api/v1/delivery-routes \
  -H "Authorization: Bearer $TOKEN"

# 4. 코스에 사업장 추가
curl -X POST http://localhost:3000/api/v1/delivery-routes/{ROUTE_ID}/stops \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "siteId": "{SITE_ID}",
    "stopNumber": 1,
    "estimatedArrival": "09:00",
    "estimatedDuration": 15
  }'
```

---

### 2.3 프론트엔드 구현 (웹 관리자)

#### Step 3-1: Types 정의

**파일**: `web/src/types/delivery-route.ts` (신규 생성)

```typescript
export type Division = 'HQ' | 'YEONGNAM';
export type DeliveryStatus = 'PENDING' | 'IN_TRANSIT' | 'ARRIVED' | 'COMPLETED' | 'DELAYED' | 'ISSUE';

export interface DeliveryRoute {
  id: string;
  name: string;
  code: string;
  division: Division;
  description?: string;
  color: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  stopsCount: number;
  assignedDrivers: Array<{
    id: string;
    name: string;
    phone: string;
  }>;
}

export interface DeliveryRouteDetail extends DeliveryRoute {
  stops: DeliveryRouteStop[];
}

export interface DeliveryRouteStop {
  id: string;
  stopNumber: number;
  estimatedArrival?: string;
  estimatedDuration?: number;
  notes?: string;
  site: {
    id: string;
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    type: string;
  };
}

export interface CreateDeliveryRouteDto {
  name: string;
  code: string;
  division: Division;
  description?: string;
  color?: string;
}

export interface UpdateDeliveryRouteDto {
  name?: string;
  description?: string;
  color?: string;
  isActive?: boolean;
}

export interface AddSiteToRouteDto {
  siteId: string;
  stopNumber: number;
  estimatedArrival?: string;
  estimatedDuration?: number;
  notes?: string;
}
```

#### Step 3-2: API Client

**파일**: `web/src/api/delivery-route.api.ts` (신규 생성)

```typescript
import axios from '../lib/axios';
import {
  DeliveryRoute,
  DeliveryRouteDetail,
  CreateDeliveryRouteDto,
  UpdateDeliveryRouteDto,
  AddSiteToRouteDto,
} from '../types/delivery-route';

/**
 * 배송 코스 목록 조회
 */
export async function getDeliveryRoutes(params?: {
  division?: string;
  isActive?: boolean;
  search?: string;
}): Promise<DeliveryRoute[]> {
  const response = await axios.get('/delivery-routes', { params });
  return response.data.data;
}

/**
 * 배송 코스 상세 조회
 */
export async function getDeliveryRouteById(id: string): Promise<DeliveryRouteDetail> {
  const response = await axios.get(`/delivery-routes/${id}`);
  return response.data.data;
}

/**
 * 배송 코스 생성
 */
export async function createDeliveryRoute(data: CreateDeliveryRouteDto): Promise<DeliveryRoute> {
  const response = await axios.post('/delivery-routes', data);
  return response.data.data;
}

/**
 * 배송 코스 수정
 */
export async function updateDeliveryRoute(
  id: string,
  data: UpdateDeliveryRouteDto
): Promise<DeliveryRoute> {
  const response = await axios.patch(`/delivery-routes/${id}`, data);
  return response.data.data;
}

/**
 * 배송 코스 삭제
 */
export async function deleteDeliveryRoute(id: string): Promise<void> {
  await axios.delete(`/delivery-routes/${id}`);
}

/**
 * 코스에 사업장 추가
 */
export async function addSiteToRoute(routeId: string, data: AddSiteToRouteDto): Promise<void> {
  await axios.post(`/delivery-routes/${routeId}/stops`, data);
}

/**
 * 코스에서 사업장 제거
 */
export async function removeSiteFromRoute(routeId: string, siteId: string): Promise<void> {
  await axios.delete(`/delivery-routes/${routeId}/stops/${siteId}`);
}

/**
 * 코스 사업장 순서 변경
 */
export async function updateRouteStops(
  routeId: string,
  stops: Array<{ id: string; stopNumber: number }>
): Promise<void> {
  await axios.put(`/delivery-routes/${routeId}/stops/reorder`, { stops });
}

/**
 * 기사 배정
 */
export async function assignDrivers(routeId: string, driverIds: string[]): Promise<void> {
  await axios.post(`/delivery-routes/${routeId}/assign-drivers`, { driverIds });
}
```

#### Step 3-3: 코스 목록 페이지

**파일**: `web/src/pages/delivery-route/DeliveryRouteListPage.tsx` (신규 생성)

```typescript
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';
import {
  Button,
  Table,
  Space,
  Tag,
  Input,
  Select,
  Card,
  Typography,
  Modal,
  message,
} from 'antd';
import {
  PlusOutlined,
  EditOutlined,
  DeleteOutlined,
  EyeOutlined,
  SearchOutlined,
} from '@ant-design/icons';
import { getDeliveryRoutes, deleteDeliveryRoute } from '../../api/delivery-route.api';
import { DeliveryRoute } from '../../types/delivery-route';
import CreateDeliveryRouteModal from '../../components/delivery-route/CreateDeliveryRouteModal';

const { Title } = Typography;

export default function DeliveryRouteListPage() {
  const navigate = useNavigate();
  const [search, setSearch] = useState('');
  const [division, setDivision] = useState<string | undefined>();
  const [isActive, setIsActive] = useState<boolean | undefined>(true);
  const [createModalOpen, setCreateModalOpen] = useState(false);

  // 배송 코스 목록 조회
  const { data: routes, isLoading, refetch } = useQuery({
    queryKey: ['delivery-routes', { division, isActive, search }],
    queryFn: () => getDeliveryRoutes({ division, isActive, search }),
  });

  // 삭제 핸들러
  const handleDelete = (route: DeliveryRoute) => {
    Modal.confirm({
      title: '배송 코스 삭제',
      content: `"${route.name}"을(를) 삭제하시겠습니까? 관련된 배송 기록은 유지됩니다.`,
      okText: '삭제',
      okType: 'danger',
      cancelText: '취소',
      onOk: async () => {
        try {
          await deleteDeliveryRoute(route.id);
          message.success('배송 코스가 삭제되었습니다');
          refetch();
        } catch (error) {
          message.error('삭제에 실패했습니다');
        }
      },
    });
  };

  // 테이블 컬럼 정의
  const columns = [
    {
      title: '코드',
      dataIndex: 'code',
      key: 'code',
      width: 80,
      render: (code: string, record: DeliveryRoute) => (
        <Tag color={record.color}>{code}</Tag>
      ),
    },
    {
      title: '코스명',
      dataIndex: 'name',
      key: 'name',
      render: (name: string) => <strong>{name}</strong>,
    },
    {
      title: '부문',
      dataIndex: 'division',
      key: 'division',
      width: 100,
      render: (division: string) => (
        <Tag color={division === 'HQ' ? 'blue' : 'green'}>
          {division === 'HQ' ? '본사' : '영남지사'}
        </Tag>
      ),
    },
    {
      title: '사업장 수',
      dataIndex: 'stopsCount',
      key: 'stopsCount',
      width: 100,
      align: 'center' as const,
    },
    {
      title: '배정 기사',
      dataIndex: 'assignedDrivers',
      key: 'assignedDrivers',
      render: (drivers: Array<{ name: string }>) => (
        <Space size={4} wrap>
          {drivers.length > 0 ? (
            drivers.map((driver, i) => (
              <Tag key={i} color="purple">
                {driver.name}
              </Tag>
            ))
          ) : (
            <span style={{ color: '#999' }}>미배정</span>
          )}
        </Space>
      ),
    },
    {
      title: '상태',
      dataIndex: 'isActive',
      key: 'isActive',
      width: 80,
      render: (isActive: boolean) => (
        <Tag color={isActive ? 'success' : 'default'}>
          {isActive ? '활성' : '비활성'}
        </Tag>
      ),
    },
    {
      title: '작업',
      key: 'actions',
      width: 150,
      render: (_: any, record: DeliveryRoute) => (
        <Space size="small">
          <Button
            type="link"
            icon={<EyeOutlined />}
            onClick={() => navigate(`/delivery-routes/${record.id}`)}
          >
            상세
          </Button>
          <Button
            type="link"
            icon={<EditOutlined />}
            onClick={() => navigate(`/delivery-routes/${record.id}/edit`)}
          />
          <Button
            type="link"
            danger
            icon={<DeleteOutlined />}
            onClick={() => handleDelete(record)}
          />
        </Space>
      ),
    },
  ];

  return (
    <div>
      <div style={{ marginBottom: 16, display: 'flex', justifyContent: 'space-between' }}>
        <Title level={2}>배송 코스 관리</Title>
        <Button
          type="primary"
          icon={<PlusOutlined />}
          onClick={() => setCreateModalOpen(true)}
        >
          코스 생성
        </Button>
      </div>

      <Card style={{ marginBottom: 16 }}>
        <Space wrap>
          <Input
            placeholder="코스명 또는 코드 검색"
            prefix={<SearchOutlined />}
            style={{ width: 200 }}
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            allowClear
          />
          <Select
            placeholder="부문 선택"
            style={{ width: 120 }}
            value={division}
            onChange={setDivision}
            allowClear
          >
            <Select.Option value="HQ">본사</Select.Option>
            <Select.Option value="YEONGNAM">영남지사</Select.Option>
          </Select>
          <Select
            placeholder="상태"
            style={{ width: 120 }}
            value={isActive}
            onChange={setIsActive}
          >
            <Select.Option value={true}>활성</Select.Option>
            <Select.Option value={false}>비활성</Select.Option>
          </Select>
        </Space>
      </Card>

      <Card>
        <Table
          columns={columns}
          dataSource={routes}
          rowKey="id"
          loading={isLoading}
          pagination={{
            showSizeChanger: true,
            showTotal: (total) => `총 ${total}개`,
          }}
        />
      </Card>

      <CreateDeliveryRouteModal
        open={createModalOpen}
        onClose={() => setCreateModalOpen(false)}
        onSuccess={() => {
          setCreateModalOpen(false);
          refetch();
        }}
      />
    </div>
  );
}
```

#### Step 3-4: 코스 생성 모달

**파일**: `web/src/components/delivery-route/CreateDeliveryRouteModal.tsx` (신규 생성)

```typescript
import React from 'react';
import { Modal, Form, Input, Select, ColorPicker, message } from 'antd';
import { useMutation } from '@tanstack/react-query';
import { createDeliveryRoute } from '../../api/delivery-route.api';
import { CreateDeliveryRouteDto } from '../../types/delivery-route';

interface Props {
  open: boolean;
  onClose: () => void;
  onSuccess: () => void;
}

export default function CreateDeliveryRouteModal({ open, onClose, onSuccess }: Props) {
  const [form] = Form.useForm<CreateDeliveryRouteDto>();

  const createMutation = useMutation({
    mutationFn: createDeliveryRoute,
    onSuccess: () => {
      message.success('배송 코스가 생성되었습니다');
      form.resetFields();
      onSuccess();
    },
    onError: (error: any) => {
      message.error(error.response?.data?.message || '생성에 실패했습니다');
    },
  });

  const handleSubmit = async () => {
    try {
      const values = await form.validateFields();
      createMutation.mutate(values);
    } catch (error) {
      console.error('Validation failed:', error);
    }
  };

  return (
    <Modal
      title="배송 코스 생성"
      open={open}
      onCancel={onClose}
      onOk={handleSubmit}
      confirmLoading={createMutation.isPending}
      okText="생성"
      cancelText="취소"
      width={600}
    >
      <Form
        form={form}
        layout="vertical"
        initialValues={{
          color: '#1890ff',
        }}
      >
        <Form.Item
          label="코스명"
          name="name"
          rules={[
            { required: true, message: '코스명을 입력해주세요' },
            { min: 2, message: '최소 2자 이상 입력해주세요' },
          ]}
        >
          <Input placeholder="예: A코스, 본사 오전 배송" maxLength={50} />
        </Form.Item>

        <Form.Item
          label="코스 코드"
          name="code"
          rules={[
            { required: true, message: '코스 코드를 입력해주세요' },
            { pattern: /^[A-Z0-9]+$/, message: '영문 대문자와 숫자만 입력 가능합니다' },
          ]}
        >
          <Input placeholder="예: A, B, C" maxLength={10} style={{ textTransform: 'uppercase' }} />
        </Form.Item>

        <Form.Item
          label="부문"
          name="division"
          rules={[{ required: true, message: '부문을 선택해주세요' }]}
        >
          <Select placeholder="부문 선택">
            <Select.Option value="HQ">본사</Select.Option>
            <Select.Option value="YEONGNAM">영남지사</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item label="코스 색상" name="color">
          <ColorPicker
            showText
            format="hex"
            presets={[
              {
                label: '추천',
                colors: [
                  '#1890ff',
                  '#52c41a',
                  '#faad14',
                  '#f5222d',
                  '#722ed1',
                  '#13c2c2',
                  '#eb2f96',
                ],
              },
            ]}
          />
        </Form.Item>

        <Form.Item label="설명" name="description">
          <Input.TextArea
            placeholder="코스에 대한 설명을 입력해주세요 (선택사항)"
            rows={3}
            maxLength={500}
          />
        </Form.Item>
      </Form>
    </Modal>
  );
}
```

---

## 3. Phase 2: 모바일 배송 기능

**기간**: 10일
**목표**: 배송기사가 모바일 앱에서 자신의 코스를 확인하고 수동으로 체크인/체크아웃

### 3.1 배송 기록 API 추가

#### Step 4-1: Delivery Log Service 추가

**파일**: `backend/src/services/delivery-log.service.ts` (신규 생성)

```typescript
import { PrismaClient, DeliveryStatus } from '@prisma/client';
import { CreateDeliveryLogDto } from '../types/delivery-route.types';

const prisma = new PrismaClient();

export class DeliveryLogService {
  /**
   * 배송 기록 생성 (체크인)
   */
  async createDeliveryLog(driverId: string, data: CreateDeliveryLogDto) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // 중복 체크
    const existing = await prisma.deliveryLog.findUnique({
      where: {
        routeId_siteId_deliveryDate: {
          routeId: data.routeId,
          siteId: data.siteId,
          deliveryDate: today,
        },
      },
    });

    if (existing) {
      // 업데이트
      return await prisma.deliveryLog.update({
        where: { id: existing.id },
        data: {
          arrivedAt: data.arrivedAt || new Date(),
          arrivalLat: data.arrivalLat,
          arrivalLng: data.arrivalLng,
          status: data.status,
          note: data.note,
        },
      });
    }

    // 신규 생성
    return await prisma.deliveryLog.create({
      data: {
        routeId: data.routeId,
        siteId: data.siteId,
        driverId,
        deliveryDate: today,
        stopNumber: data.stopNumber,
        arrivedAt: data.arrivedAt || new Date(),
        arrivalLat: data.arrivalLat,
        arrivalLng: data.arrivalLng,
        status: data.status,
        note: data.note,
      },
    });
  }

  /**
   * 배송 완료 (체크아웃)
   */
  async completeDelivery(logId: string, data: {
    departureLat?: number;
    departureLng?: number;
    note?: string;
  }) {
    const log = await prisma.deliveryLog.findUnique({
      where: { id: logId },
    });

    if (!log) {
      throw new Error('배송 기록을 찾을 수 없습니다');
    }

    const departedAt = new Date();
    const actualDuration = log.arrivedAt
      ? Math.floor((departedAt.getTime() - log.arrivedAt.getTime()) / 60000)
      : null;

    return await prisma.deliveryLog.update({
      where: { id: logId },
      data: {
        departedAt,
        departureLat: data.departureLat,
        departureLng: data.departureLng,
        status: 'COMPLETED',
        actualDuration,
        note: data.note || log.note,
      },
    });
  }

  /**
   * 오늘의 배송 기록 조회
   */
  async getTodayDeliveryLogs(driverId: string, routeId: string) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    return await prisma.deliveryLog.findMany({
      where: {
        driverId,
        routeId,
        deliveryDate: today,
      },
      include: {
        site: {
          select: {
            id: true,
            name: true,
            address: true,
            latitude: true,
            longitude: true,
          },
        },
      },
      orderBy: { stopNumber: 'asc' },
    });
  }

  /**
   * 배송 기록 이력 조회 (관리자용)
   */
  async getDeliveryHistory(filters: {
    routeId?: string;
    driverId?: string;
    startDate?: Date;
    endDate?: Date;
    status?: DeliveryStatus;
  }) {
    const where: any = {};

    if (filters.routeId) where.routeId = filters.routeId;
    if (filters.driverId) where.driverId = filters.driverId;
    if (filters.status) where.status = filters.status;
    if (filters.startDate || filters.endDate) {
      where.deliveryDate = {};
      if (filters.startDate) where.deliveryDate.gte = filters.startDate;
      if (filters.endDate) where.deliveryDate.lte = filters.endDate;
    }

    return await prisma.deliveryLog.findMany({
      where,
      include: {
        site: {
          select: { id: true, name: true, address: true },
        },
        driver: {
          select: { id: true, name: true, phone: true },
        },
        route: {
          select: { id: true, name: true, code: true },
        },
      },
      orderBy: [{ deliveryDate: 'desc' }, { stopNumber: 'asc' }],
    });
  }
}
```

#### Step 4-2: Delivery Log Controller & Routes

**파일**: `backend/src/controllers/delivery-log.controller.ts` (신규 생성)

```typescript
import { Request, Response, NextFunction } from 'express';
import { DeliveryLogService } from '../services/delivery-log.service';

const deliveryLogService = new DeliveryLogService();

/**
 * POST /api/v1/delivery-logs/check-in
 * 체크인 (도착)
 */
export async function checkIn(req: Request, res: Response, next: NextFunction) {
  try {
    const driverId = req.user?.id;
    if (!driverId) {
      return res.status(401).json({ success: false, message: '인증이 필요합니다' });
    }

    const log = await deliveryLogService.createDeliveryLog(driverId, req.body);

    res.status(201).json({
      success: true,
      data: log,
      message: '체크인되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-logs/:id/check-out
 * 체크아웃 (출발)
 */
export async function checkOut(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const log = await deliveryLogService.completeDelivery(id, req.body);

    res.json({
      success: true,
      data: log,
      message: '배송이 완료되었습니다',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-logs/today
 * 오늘의 배송 기록 조회
 */
export async function getTodayLogs(req: Request, res: Response, next: NextFunction) {
  try {
    const driverId = req.user?.id;
    const { routeId } = req.query;

    if (!driverId || !routeId) {
      return res.status(400).json({ success: false, message: '필수 파라미터가 누락되었습니다' });
    }

    const logs = await deliveryLogService.getTodayDeliveryLogs(driverId, routeId as string);

    res.json({
      success: true,
      data: logs,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-logs/history
 * 배송 기록 이력 조회 (관리자)
 */
export async function getHistory(req: Request, res: Response, next: NextFunction) {
  try {
    const { routeId, driverId, startDate, endDate, status } = req.query;

    const logs = await deliveryLogService.getDeliveryHistory({
      routeId: routeId as string | undefined,
      driverId: driverId as string | undefined,
      startDate: startDate ? new Date(startDate as string) : undefined,
      endDate: endDate ? new Date(endDate as string) : undefined,
      status: status as any,
    });

    res.json({
      success: true,
      data: logs,
    });
  } catch (error) {
    next(error);
  }
}
```

**파일**: `backend/src/routes/delivery-log.routes.ts` (신규 생성)

```typescript
import { Router } from 'express';
import * as deliveryLogController from '../controllers/delivery-log.controller';
import { authenticate } from '../middleware/auth.middleware';
import { authorize } from '../middleware/role.middleware';
import { validate } from '../middleware/validation.middleware';
import { createDeliveryLogSchema } from '../validators/delivery-route.validator';

const router = Router();

router.use(authenticate);

// 배송기사용
router.post(
  '/check-in',
  authorize(['DELIVERY_DRIVER']),
  validate({ body: createDeliveryLogSchema }),
  deliveryLogController.checkIn
);

router.post(
  '/:id/check-out',
  authorize(['DELIVERY_DRIVER']),
  deliveryLogController.checkOut
);

router.get(
  '/today',
  authorize(['DELIVERY_DRIVER']),
  deliveryLogController.getTodayLogs
);

// 관리자용
router.get(
  '/history',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  deliveryLogController.getHistory
);

export default router;
```

**파일**: `backend/src/routes/index.ts` (수정 - 라우트 추가)

```typescript
import deliveryLogRoutes from './delivery-log.routes';

// ...
app.use('/api/v1/delivery-logs', deliveryLogRoutes);
```

---

### 3.2 모바일 앱 구현

#### Step 5-1: Types & API Client

**파일**: `mobile/src/types/delivery-route.ts` (신규 생성)

```typescript
export interface DeliveryRoute {
  id: string;
  name: string;
  code: string;
  color: string;
  stopsCount: number;
  stops: DeliveryRouteStop[];
}

export interface DeliveryRouteStop {
  id: string;
  stopNumber: number;
  estimatedArrival?: string;
  estimatedDuration?: number;
  notes?: string;
  site: {
    id: string;
    name: string;
    address: string;
    latitude: number;
    longitude: number;
  };
}

export interface DeliveryLog {
  id: string;
  routeId: string;
  siteId: string;
  stopNumber: number;
  arrivedAt?: string;
  departedAt?: string;
  status: 'PENDING' | 'IN_TRANSIT' | 'ARRIVED' | 'COMPLETED' | 'DELAYED' | 'ISSUE';
  site: {
    id: string;
    name: string;
    address: string;
  };
}
```

**파일**: `mobile/src/api/delivery-route.api.ts` (신규 생성)

```typescript
import api from './client';
import { DeliveryRoute, DeliveryLog } from '../types/delivery-route';

/**
 * 내 배송 코스 조회
 */
export async function getMyRoutes(): Promise<DeliveryRoute[]> {
  const response = await api.get('/delivery-routes/my-routes');
  return response.data.data;
}

/**
 * 오늘의 배송 기록 조회
 */
export async function getTodayDeliveryLogs(routeId: string): Promise<DeliveryLog[]> {
  const response = await api.get('/delivery-logs/today', {
    params: { routeId },
  });
  return response.data.data;
}

/**
 * 체크인
 */
export async function checkIn(data: {
  routeId: string;
  siteId: string;
  stopNumber: number;
  arrivalLat?: number;
  arrivalLng?: number;
  status: string;
  note?: string;
}): Promise<DeliveryLog> {
  const response = await api.post('/delivery-logs/check-in', data);
  return response.data.data;
}

/**
 * 체크아웃
 */
export async function checkOut(logId: string, data: {
  departureLat?: number;
  departureLng?: number;
  note?: string;
}): Promise<DeliveryLog> {
  const response = await api.post(`/delivery-logs/${logId}/check-out`, data);
  return response.data.data;
}
```

#### Step 5-2: 배송 코스 화면

**파일**: `mobile/src/screens/DeliveryRouteScreen.tsx` (신규 생성)

```typescript
import React, { useState } from 'react';
import { View, Text, ScrollView, TouchableOpacity, StyleSheet, Alert } from 'react-native';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as Location from 'expo-location';
import { getMyRoutes, getTodayDeliveryLogs, checkIn, checkOut } from '../api/delivery-route.api';
import { DeliveryRoute, DeliveryLog } from '../types/delivery-route';

export default function DeliveryRouteScreen() {
  const queryClient = useQueryClient();
  const [selectedRoute, setSelectedRoute] = useState<DeliveryRoute | null>(null);

  // 내 코스 목록 조회
  const { data: routes, isLoading: routesLoading } = useQuery({
    queryKey: ['my-routes'],
    queryFn: getMyRoutes,
  });

  // 오늘의 배송 기록
  const { data: logs, refetch: refetchLogs } = useQuery({
    queryKey: ['today-logs', selectedRoute?.id],
    queryFn: () => getTodayDeliveryLogs(selectedRoute!.id),
    enabled: !!selectedRoute,
  });

  // 체크인 Mutation
  const checkInMutation = useMutation({
    mutationFn: async (stop: any) => {
      // GPS 좌표 가져오기
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        throw new Error('위치 권한이 필요합니다');
      }

      const location = await Location.getCurrentPositionAsync({});

      return checkIn({
        routeId: selectedRoute!.id,
        siteId: stop.site.id,
        stopNumber: stop.stopNumber,
        arrivalLat: location.coords.latitude,
        arrivalLng: location.coords.longitude,
        status: 'ARRIVED',
      });
    },
    onSuccess: () => {
      Alert.alert('성공', '체크인되었습니다');
      refetchLogs();
    },
    onError: (error: any) => {
      Alert.alert('오류', error.message || '체크인에 실패했습니다');
    },
  });

  // 체크아웃 Mutation
  const checkOutMutation = useMutation({
    mutationFn: async (logId: string) => {
      const location = await Location.getCurrentPositionAsync({});

      return checkOut(logId, {
        departureLat: location.coords.latitude,
        departureLng: location.coords.longitude,
      });
    },
    onSuccess: () => {
      Alert.alert('성공', '배송이 완료되었습니다');
      refetchLogs();
    },
    onError: (error: any) => {
      Alert.alert('오류', error.message || '체크아웃에 실패했습니다');
    },
  });

  // 로그인 로드 중
  if (routesLoading) {
    return (
      <View style={styles.container}>
        <Text>로딩 중...</Text>
      </View>
    );
  }

  // 코스 선택 화면
  if (!selectedRoute) {
    return (
      <View style={styles.container}>
        <Text style={styles.title}>내 배송 코스</Text>
        {routes?.map((route) => (
          <TouchableOpacity
            key={route.id}
            style={[styles.routeCard, { borderLeftColor: route.color }]}
            onPress={() => setSelectedRoute(route)}
          >
            <View style={styles.routeHeader}>
              <Text style={styles.routeCode}>{route.code}</Text>
              <Text style={styles.routeName}>{route.name}</Text>
            </View>
            <Text style={styles.stopsCount}>사업장 {route.stopsCount}개</Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  }

  // 배송 진행 화면
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => setSelectedRoute(null)}>
          <Text style={styles.backButton}>← 뒤로</Text>
        </TouchableOpacity>
        <Text style={styles.title}>{selectedRoute.name}</Text>
      </View>

      <ScrollView>
        {selectedRoute.stops.map((stop, index) => {
          const log = logs?.find((l) => l.siteId === stop.site.id);
          const isCompleted = log?.status === 'COMPLETED';
          const isArrived = log?.status === 'ARRIVED';

          return (
            <View key={stop.id} style={styles.stopCard}>
              <View style={styles.stopHeader}>
                <View style={styles.stopNumberBadge}>
                  <Text style={styles.stopNumberText}>{stop.stopNumber}</Text>
                </View>
                <View style={styles.stopInfo}>
                  <Text style={styles.siteName}>{stop.site.name}</Text>
                  <Text style={styles.siteAddress}>{stop.site.address}</Text>
                  {stop.estimatedArrival && (
                    <Text style={styles.estimatedTime}>
                      예상 도착: {stop.estimatedArrival}
                    </Text>
                  )}
                </View>
              </View>

              {isCompleted ? (
                <View style={styles.completedBadge}>
                  <Text style={styles.completedText}>✓ 완료</Text>
                  {log.arrivedAt && (
                    <Text style={styles.timeText}>
                      도착: {new Date(log.arrivedAt).toLocaleTimeString('ko-KR', {
                        hour: '2-digit',
                        minute: '2-digit',
                      })}
                    </Text>
                  )}
                </View>
              ) : isArrived ? (
                <TouchableOpacity
                  style={styles.checkoutButton}
                  onPress={() => checkOutMutation.mutate(log.id)}
                  disabled={checkOutMutation.isPending}
                >
                  <Text style={styles.buttonText}>
                    {checkOutMutation.isPending ? '처리 중...' : '체크아웃'}
                  </Text>
                </TouchableOpacity>
              ) : (
                <TouchableOpacity
                  style={styles.checkinButton}
                  onPress={() => checkInMutation.mutate(stop)}
                  disabled={checkInMutation.isPending}
                >
                  <Text style={styles.buttonText}>
                    {checkInMutation.isPending ? '처리 중...' : '체크인'}
                  </Text>
                </TouchableOpacity>
              )}

              {stop.notes && (
                <Text style={styles.notes}>메모: {stop.notes}</Text>
              )}
            </View>
          );
        })}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  backButton: {
    fontSize: 16,
    color: '#1890ff',
    marginRight: 12,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  routeCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    borderLeftWidth: 4,
    elevation: 2,
  },
  routeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  routeCode: {
    fontSize: 18,
    fontWeight: 'bold',
    marginRight: 8,
  },
  routeName: {
    fontSize: 18,
  },
  stopsCount: {
    fontSize: 14,
    color: '#666',
  },
  stopCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 2,
  },
  stopHeader: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  stopNumberBadge: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#1890ff',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  stopNumberText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
  },
  stopInfo: {
    flex: 1,
  },
  siteName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  siteAddress: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  estimatedTime: {
    fontSize: 12,
    color: '#1890ff',
  },
  checkinButton: {
    backgroundColor: '#52c41a',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  checkoutButton: {
    backgroundColor: '#faad14',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  completedBadge: {
    backgroundColor: '#f0f0f0',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  completedText: {
    color: '#52c41a',
    fontWeight: 'bold',
    fontSize: 16,
  },
  timeText: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  buttonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
  },
  notes: {
    fontSize: 12,
    color: '#666',
    marginTop: 8,
    fontStyle: 'italic',
  },
});
```

---

## 4. Phase 3: GPS 자동 추적

**기간**: 5일
**목표**: 백그라운드 위치 추적 및 Geofencing을 통한 자동 체크인 제안

### 4.1 백그라운드 위치 추적 구현

**파일**: `mobile/src/services/location-tracking.ts` (신규 생성)

```typescript
import * as Location from 'expo-location';
import * as TaskManager from 'expo-task-manager';
import AsyncStorage from '@react-native-async-storage/async-storage';

const LOCATION_TASK_NAME = 'background-location-task';
const GEOFENCE_TASK_NAME = 'delivery-geofence-task';

/**
 * 백그라운드 위치 추적 태스크 정의
 */
TaskManager.defineTask(LOCATION_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error('Location task error:', error);
    return;
  }

  if (data) {
    const { locations } = data as any;
    const location = locations[0];

    // 위치 데이터를 저장하거나 서버로 전송
    try {
      await sendLocationToServer({
        latitude: location.coords.latitude,
        longitude: location.coords.longitude,
        timestamp: new Date(location.timestamp),
      });
    } catch (err) {
      console.error('Failed to send location:', err);
    }
  }
});

/**
 * Geofencing 태스크 정의
 */
TaskManager.defineTask(GEOFENCE_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error('Geofence task error:', error);
    return;
  }

  if (data) {
    const { eventType, region } = data as any;

    if (eventType === Location.GeofencingEventType.Enter) {
      // 사업장 반경 진입 → 체크인 알림
      await showCheckInNotification(region.identifier);
    }
  }
});

/**
 * 백그라운드 위치 추적 시작
 */
export async function startLocationTracking() {
  // 권한 확인
  const { status: foregroundStatus } = await Location.requestForegroundPermissionsAsync();
  if (foregroundStatus !== 'granted') {
    throw new Error('위치 권한이 필요합니다');
  }

  const { status: backgroundStatus } = await Location.requestBackgroundPermissionsAsync();
  if (backgroundStatus !== 'granted') {
    throw new Error('백그라운드 위치 권한이 필요합니다');
  }

  // 위치 추적 시작
  await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
    accuracy: Location.Accuracy.High,
    timeInterval: 30000, // 30초마다
    distanceInterval: 100, // 100m 이동 시
    foregroundService: {
      notificationTitle: '배송 중',
      notificationBody: '위치가 추적되고 있습니다',
      notificationColor: '#1890ff',
    },
    pausesUpdatesAutomatically: false,
    showsBackgroundLocationIndicator: true,
  });

  await AsyncStorage.setItem('location_tracking', 'true');
}

/**
 * 백그라운드 위치 추적 중지
 */
export async function stopLocationTracking() {
  await Location.stopLocationUpdatesAsync(LOCATION_TASK_NAME);
  await AsyncStorage.setItem('location_tracking', 'false');
}

/**
 * Geofencing 설정
 */
export async function setupGeofencing(stops: Array<{
  id: string;
  latitude: number;
  longitude: number;
}>) {
  const regions = stops.map((stop) => ({
    identifier: stop.id,
    latitude: stop.latitude,
    longitude: stop.longitude,
    radius: 100, // 100m 반경
    notifyOnEnter: true,
    notifyOnExit: false,
  }));

  await Location.startGeofencingAsync(GEOFENCE_TASK_NAME, regions);
}

/**
 * Geofencing 해제
 */
export async function stopGeofencing() {
  await Location.stopGeofencingAsync(GEOFENCE_TASK_NAME);
}

/**
 * 위치 데이터 서버 전송
 */
async function sendLocationToServer(location: {
  latitude: number;
  longitude: number;
  timestamp: Date;
}) {
  // API 호출 (실제 구현 필요)
  console.log('Sending location:', location);
}

/**
 * 체크인 알림 표시
 */
async function showCheckInNotification(siteId: string) {
  // 로컬 알림 표시 (실제 구현 필요)
  console.log('Show check-in notification for site:', siteId);
}
```

**파일**: `mobile/src/screens/DeliveryControlScreen.tsx` (신규 생성)

```typescript
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Switch } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { startLocationTracking, stopLocationTracking } from '../services/location-tracking';

export default function DeliveryControlScreen() {
  const [isTracking, setIsTracking] = useState(false);

  useEffect(() => {
    checkTrackingStatus();
  }, []);

  const checkTrackingStatus = async () => {
    const status = await AsyncStorage.getItem('location_tracking');
    setIsTracking(status === 'true');
  };

  const handleToggleTracking = async () => {
    try {
      if (isTracking) {
        await stopLocationTracking();
        setIsTracking(false);
      } else {
        await startLocationTracking();
        setIsTracking(true);
      }
    } catch (error: any) {
      alert(error.message);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>배송 설정</Text>

      <View style={styles.card}>
        <View style={styles.row}>
          <View style={styles.textContainer}>
            <Text style={styles.label}>배송 추적</Text>
            <Text style={styles.description}>
              배송 중 위치를 자동으로 기록합니다
            </Text>
          </View>
          <Switch
            value={isTracking}
            onValueChange={handleToggleTracking}
            trackColor={{ false: '#767577', true: '#52c41a' }}
            thumbColor={isTracking ? '#fff' : '#f4f3f4'}
          />
        </View>

        {isTracking && (
          <View style={styles.statusContainer}>
            <View style={styles.statusIndicator} />
            <Text style={styles.statusText}>추적 중</Text>
          </View>
        )}
      </View>

      <View style={styles.infoCard}>
        <Text style={styles.infoTitle}>배송 추적 안내</Text>
        <Text style={styles.infoText}>
          • 30초마다 또는 100m 이동 시 위치가 기록됩니다{'\n'}
          • 배송 시작 시 추적을 켜고, 종료 시 꺼주세요{'\n'}
          • 배터리 절약을 위해 배송이 아닐 때는 꺼두는 것을 권장합니다{'\n'}
          • 사업장 근처 도착 시 자동으로 알림을 받을 수 있습니다
        </Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  card: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  textContainer: {
    flex: 1,
  },
  label: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  description: {
    fontSize: 14,
    color: '#666',
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  statusIndicator: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: '#52c41a',
    marginRight: 8,
  },
  statusText: {
    fontSize: 14,
    color: '#52c41a',
    fontWeight: 'bold',
  },
  infoCard: {
    backgroundColor: '#e6f7ff',
    borderRadius: 8,
    padding: 16,
    borderLeftWidth: 4,
    borderLeftColor: '#1890ff',
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#1890ff',
  },
  infoText: {
    fontSize: 14,
    color: '#666',
    lineHeight: 20,
  },
});
```

---

## 5. Phase 4: 경로 최적화

**기간**: 5일
**목표**: Kakao Mobility API를 활용한 경로 시뮬레이션 및 최적화

### 5.1 경로 최적화 Service

**파일**: `backend/src/services/route-optimization.service.ts` (신규 생성)

```typescript
import axios from 'axios';
import { DeliveryRouteStop } from '@prisma/client';

interface RouteSegment {
  from: string;
  to: string;
  distance: number;
  duration: number;
  estimatedArrival: string;
}

export class RouteOptimizationService {
  private kakaoRestApiKey = process.env.KAKAO_REST_API_KEY!;

  /**
   * 두 지점 간 이동 시간 및 거리 계산
   */
  async calculateRoute(
    origin: { lat: number; lng: number },
    destination: { lat: number; lng: number }
  ): Promise<{
    distanceMeters: number;
    durationSeconds: number;
    distanceKm: number;
    durationMinutes: number;
  }> {
    const url = 'https://apis-navi.kakaomobility.com/v1/directions';

    try {
      const response = await axios.get(url, {
        params: {
          origin: `${origin.lng},${origin.lat}`,
          destination: `${destination.lng},${destination.lat}`,
          priority: 'RECOMMEND',
        },
        headers: {
          Authorization: `KakaoAK ${this.kakaoRestApiKey}`,
        },
      });

      const route = response.data.routes[0];

      return {
        distanceMeters: route.summary.distance,
        durationSeconds: route.summary.duration,
        distanceKm: route.summary.distance / 1000,
        durationMinutes: Math.ceil(route.summary.duration / 60),
      };
    } catch (error) {
      console.error('Kakao Mobility API error:', error);
      throw new Error('경로 계산에 실패했습니다');
    }
  }

  /**
   * 전체 코스 시뮬레이션
   */
  async simulateRoute(stops: Array<{
    stopNumber: number;
    site: {
      name: string;
      latitude: number;
      longitude: number;
    };
  }>, startTime: Date = new Date()) {
    const segments: RouteSegment[] = [];
    let totalDistance = 0;
    let totalDuration = 0;
    let currentTime = new Date(startTime);

    for (let i = 0; i < stops.length - 1; i++) {
      const origin = {
        lat: stops[i].site.latitude,
        lng: stops[i].site.longitude,
      };
      const destination = {
        lat: stops[i + 1].site.latitude,
        lng: stops[i + 1].site.longitude,
      };

      const route = await this.calculateRoute(origin, destination);

      totalDistance += route.distanceKm;
      totalDuration += route.durationMinutes;

      // 정류장 체류 시간 (15분) 추가
      const stopDuration = 15;
      currentTime = new Date(currentTime.getTime() + (route.durationMinutes + stopDuration) * 60000);

      segments.push({
        from: stops[i].site.name,
        to: stops[i + 1].site.name,
        distance: route.distanceKm,
        duration: route.durationMinutes,
        estimatedArrival: currentTime.toISOString(),
      });
    }

    return {
      totalDistance: Math.round(totalDistance * 10) / 10,
      totalDuration: totalDuration + (stops.length * 15), // 각 정류장 15분
      segments,
    };
  }

  /**
   * 경로 최적화 (간단한 Nearest Neighbor 알고리즘)
   */
  async optimizeRoute(
    sites: Array<{ id: string; name: string; latitude: number; longitude: number }>,
    startPoint: { lat: number; lng: number }
  ) {
    const unvisited = [...sites];
    const optimized: typeof sites = [];
    let current = startPoint;

    while (unvisited.length > 0) {
      let nearest = null;
      let minDistance = Infinity;

      for (const site of unvisited) {
        const route = await this.calculateRoute(current, {
          lat: site.latitude,
          lng: site.longitude,
        });

        if (route.distanceKm < minDistance) {
          minDistance = route.distanceKm;
          nearest = site;
        }
      }

      if (nearest) {
        optimized.push(nearest);
        current = { lat: nearest.latitude, lng: nearest.longitude };
        unvisited.splice(unvisited.indexOf(nearest), 1);
      }
    }

    return optimized;
  }
}
```

### 5.2 경로 시뮬레이션 Controller & Routes

**파일**: `backend/src/controllers/route-optimization.controller.ts` (신규 생성)

```typescript
import { Request, Response, NextFunction } from 'express';
import { RouteOptimizationService } from '../services/route-optimization.service';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const routeOptimizationService = new RouteOptimizationService();

/**
 * POST /api/v1/delivery-routes/:id/simulate
 * 경로 시뮬레이션
 */
export async function simulateRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const { startTime } = req.body;

    // 코스 정보 조회
    const route = await prisma.deliveryRoute.findUnique({
      where: { id },
      include: {
        routeStops: {
          where: { isActive: true },
          include: {
            site: {
              select: {
                name: true,
                latitude: true,
                longitude: true,
              },
            },
          },
          orderBy: { stopNumber: 'asc' },
        },
      },
    });

    if (!route) {
      return res.status(404).json({
        success: false,
        message: '코스를 찾을 수 없습니다',
      });
    }

    // 시뮬레이션 실행
    const simulation = await routeOptimizationService.simulateRoute(
      route.routeStops,
      startTime ? new Date(startTime) : new Date('2025-01-01 08:00')
    );

    res.json({
      success: true,
      data: simulation,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes/:id/optimize
 * 경로 최적화
 */
export async function optimizeRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const { startLat, startLng } = req.body;

    // 코스 정보 조회
    const route = await prisma.deliveryRoute.findUnique({
      where: { id },
      include: {
        routeStops: {
          where: { isActive: true },
          include: {
            site: {
              select: {
                id: true,
                name: true,
                latitude: true,
                longitude: true,
              },
            },
          },
        },
      },
    });

    if (!route) {
      return res.status(404).json({
        success: false,
        message: '코스를 찾을 수 없습니다',
      });
    }

    // 최적화 실행
    const sites = route.routeStops.map((stop) => stop.site);
    const optimized = await routeOptimizationService.optimizeRoute(sites, {
      lat: startLat,
      lng: startLng,
    });

    res.json({
      success: true,
      data: optimized,
      message: '최적 경로가 계산되었습니다',
    });
  } catch (error) {
    next(error);
  }
}
```

**파일**: `backend/src/routes/delivery-route.routes.ts` (수정 - 라우트 추가)

```typescript
import * as routeOptimizationController from '../controllers/route-optimization.controller';

// ... 기존 라우트

/**
 * POST /api/v1/delivery-routes/:id/simulate
 * 경로 시뮬레이션
 */
router.post(
  '/:id/simulate',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  routeOptimizationController.simulateRoute
);

/**
 * POST /api/v1/delivery-routes/:id/optimize
 * 경로 최적화
 */
router.post(
  '/:id/optimize',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  routeOptimizationController.optimizeRoute
);
```

### 5.3 웹 관리자 - 시뮬레이션 페이지

**파일**: `web/src/pages/delivery-route/RouteSimulationPage.tsx` (신규 생성)

```typescript
import React, { useState } from 'react';
import { useParams } from 'react-router-dom';
import { useQuery, useMutation } from '@tanstack/react-query';
import { Card, Button, Statistic, Timeline, Space, message, Spin } from 'antd';
import { PlayCircleOutlined, ThunderboltOutlined } from '@ant-design/icons';
import { getDeliveryRouteById } from '../../api/delivery-route.api';
import axios from '../../lib/axios';

export default function RouteSimulationPage() {
  const { id } = useParams<{ id: string }>();
  const [simulation, setSimulation] = useState<any>(null);

  // 코스 정보 조회
  const { data: route, isLoading } = useQuery({
    queryKey: ['delivery-route', id],
    queryFn: () => getDeliveryRouteById(id!),
  });

  // 시뮬레이션 실행
  const simulateMutation = useMutation({
    mutationFn: async () => {
      const response = await axios.post(`/delivery-routes/${id}/simulate`, {
        startTime: new Date('2025-01-01 08:00').toISOString(),
      });
      return response.data.data;
    },
    onSuccess: (data) => {
      setSimulation(data);
      message.success('시뮬레이션이 완료되었습니다');
    },
    onError: () => {
      message.error('시뮬레이션에 실패했습니다');
    },
  });

  if (isLoading) {
    return (
      <div style={{ textAlign: 'center', padding: 50 }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <div style={{ padding: 24 }}>
      <Card>
        <h2>{route?.name} - 경로 시뮬레이션</h2>
        <p>총 사업장: {route?.stopsCount}개</p>

        <Button
          type="primary"
          icon={<PlayCircleOutlined />}
          onClick={() => simulateMutation.mutate()}
          loading={simulateMutation.isPending}
          size="large"
        >
          시뮬레이션 실행
        </Button>
      </Card>

      {simulation && (
        <>
          <Card style={{ marginTop: 16 }}>
            <Space size="large">
              <Statistic
                title="총 거리"
                value={simulation.totalDistance}
                suffix="km"
              />
              <Statistic
                title="총 소요 시간"
                value={simulation.totalDuration}
                suffix="분"
              />
              <Statistic
                title="평균 속도"
                value={Math.round((simulation.totalDistance / simulation.totalDuration) * 60)}
                suffix="km/h"
              />
            </Space>
          </Card>

          <Card title="경로 상세" style={{ marginTop: 16 }}>
            <Timeline>
              {simulation.segments.map((segment: any, i: number) => (
                <Timeline.Item key={i}>
                  <strong>{segment.to}</strong>
                  <br />
                  <span style={{ color: '#666' }}>
                    도착 예정: {new Date(segment.estimatedArrival).toLocaleTimeString('ko-KR', {
                      hour: '2-digit',
                      minute: '2-digit',
                    })}
                  </span>
                  <br />
                  <span style={{ color: '#999', fontSize: 12 }}>
                    소요: {segment.duration}분 ({segment.distance.toFixed(1)}km)
                  </span>
                </Timeline.Item>
              ))}
            </Timeline>
          </Card>
        </>
      )}
    </div>
  );
}
```

---

## 6. 테스트 계획

### 6.1 단위 테스트

**백엔드 Service 테스트**

```bash
# Jest 설치
npm install --save-dev jest @types/jest ts-jest

# 테스트 파일: backend/src/services/__tests__/delivery-route.service.test.ts
```

```typescript
import { DeliveryRouteService } from '../delivery-route.service';

describe('DeliveryRouteService', () => {
  let service: DeliveryRouteService;

  beforeEach(() => {
    service = new DeliveryRouteService();
  });

  describe('createDeliveryRoute', () => {
    it('should create a new delivery route', async () => {
      const dto = {
        name: 'A코스',
        code: 'A',
        division: 'HQ',
        description: '본사 오전 배송',
      };

      const result = await service.createDeliveryRoute(dto as any);

      expect(result).toHaveProperty('id');
      expect(result.name).toBe('A코스');
    });

    it('should throw error for duplicate code', async () => {
      // 중복 테스트
    });
  });
});
```

### 6.2 통합 테스트

**API 엔드포인트 테스트**

```bash
# Supertest 설치
npm install --save-dev supertest @types/supertest
```

```typescript
import request from 'supertest';
import app from '../app';

describe('Delivery Route API', () => {
  let authToken: string;

  beforeAll(async () => {
    // 로그인하여 토큰 받기
    const response = await request(app)
      .post('/api/v1/auth/login')
      .send({ phone: '01012345678', password: '1234' });

    authToken = response.body.data.token;
  });

  describe('POST /api/v1/delivery-routes', () => {
    it('should create a new route with valid data', async () => {
      const response = await request(app)
        .post('/api/v1/delivery-routes')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: 'Test Route',
          code: 'TEST',
          division: 'HQ',
        });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
    });

    it('should return 422 for invalid data', async () => {
      const response = await request(app)
        .post('/api/v1/delivery-routes')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: 'A', // Too short
        });

      expect(response.status).toBe(422);
    });
  });
});
```

### 6.3 모바일 테스트

**React Native Testing Library**

```bash
cd mobile
npm install --save-dev @testing-library/react-native
```

```typescript
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import DeliveryRouteScreen from '../DeliveryRouteScreen';

describe('DeliveryRouteScreen', () => {
  it('should display routes', async () => {
    const { getByText } = render(<DeliveryRouteScreen />);

    await waitFor(() => {
      expect(getByText('A코스')).toBeTruthy();
    });
  });

  it('should handle check-in', async () => {
    const { getByText } = render(<DeliveryRouteScreen />);

    const checkinButton = getByText('체크인');
    fireEvent.press(checkinButton);

    await waitFor(() => {
      expect(getByText('체크인되었습니다')).toBeTruthy();
    });
  });
});
```

---

## 7. 배포 체크리스트

### 7.1 Phase 1 배포 전 체크리스트

**데이터베이스**
- [ ] 프로덕션 DB 백업 완료
- [ ] 마이그레이션 테스트 완료 (로컬)
- [ ] 마이그레이션 롤백 계획 수립

**백엔드**
- [ ] 모든 API 엔드포인트 테스트 완료
- [ ] Validator 검증 완료
- [ ] 에러 핸들링 확인
- [ ] 권한 체크 확인 (역할별 접근 제어)

**프론트엔드**
- [ ] 코스 생성 기능 테스트
- [ ] 코스 수정 기능 테스트
- [ ] 사업장 추가/제거 테스트
- [ ] 순서 변경 (Drag & Drop) 테스트

**배포**
- [ ] Git 커밋 및 푸시 완료
- [ ] 프로덕션 서버 SSH 접속 확인
- [ ] PM2 상태 확인
- [ ] 배포 후 API Health Check

### 7.2 Phase 2 배포 전 체크리스트

**백엔드**
- [ ] 배송 기록 API 테스트
- [ ] 체크인/체크아웃 로직 검증
- [ ] GPS 좌표 저장 확인

**모바일**
- [ ] Android 빌드 성공
- [ ] iOS 빌드 성공 (Mac이 있는 경우)
- [ ] 위치 권한 요청 동작 확인
- [ ] 체크인/체크아웃 UI 테스트
- [ ] 오프라인 대응 확인

**테스트**
- [ ] 실제 기기에서 GPS 테스트
- [ ] 네트워크 연결 끊김 시나리오 테스트
- [ ] 배터리 소모 모니터링

### 7.3 Phase 3 배포 전 체크리스트

**모바일**
- [ ] 백그라운드 권한 요청 확인
- [ ] Foreground Service 알림 표시 확인
- [ ] Geofencing 동작 확인
- [ ] 배터리 최적화 설정 안내

**테스트**
- [ ] 장시간 (4시간+) 백그라운드 추적 테스트
- [ ] 앱 종료 후에도 추적 유지 확인
- [ ] 사업장 반경 진입 시 알림 확인

### 7.4 Phase 4 배포 전 체크리스트

**백엔드**
- [ ] Kakao Mobility API 키 설정 확인
- [ ] API 호출 한도 모니터링 설정
- [ ] 에러 처리 (API 실패 시)

**프론트엔드**
- [ ] 시뮬레이션 결과 표시 확인
- [ ] 최적화 결과 저장 기능 확인

**테스트**
- [ ] 실제 좌표로 경로 계산 테스트
- [ ] API 호출 횟수 확인 (무료 한도 내)

### 7.5 최종 배포 명령어

```bash
# 1. 로컬에서 최종 테스트
cd backend
npm run build
npm test

cd ../web
npm run build

cd ../mobile
npx expo doctor

# 2. Git 커밋
git add .
git commit -m "feat: Complete delivery route management system

Phase 1: Basic route management
Phase 2: Mobile delivery tracking
Phase 3: GPS auto-tracking
Phase 4: Route optimization

- Add 4 new database models
- Implement backend APIs
- Create web admin pages
- Build mobile delivery app
- Integrate Kakao Mobility API"

git push

# 3. 프로덕션 배포
ssh root@165.246.44.4
cd ~/daham_voc

# 백업
pg_dump -U daham_user daham_voc > ~/backups/before_delivery_$(date +%Y%m%d).sql

# 배포
git pull
cd backend
npx prisma migrate deploy
npx prisma generate
npm install
npm run build
pm2 restart daham-voc-api

# 4. 확인
pm2 status
pm2 logs daham-voc-api --lines 50

# 5. API 테스트
curl https://api.dahamvoc.co.kr/health

# 6. 모바일 앱 빌드 (EAS)
cd ~/daham_voc/mobile
eas build --platform android --profile production
```

---

## 8. 참고 자료

### 8.1 API 문서

**Kakao Mobility API**
- [길찾기 API](https://developers.kakaomobility.com/docs/navi-api/directions/)
- [주소 검색 API](https://developers.kakao.com/docs/latest/ko/local/dev-guide)

**Expo Location**
- [공식 문서](https://docs.expo.dev/versions/latest/sdk/location/)
- [Background Location](https://docs.expo.dev/versions/latest/sdk/task-manager/)

### 8.2 내부 문서

- [배송코스_시스템_검토서.md](./배송코스_시스템_검토서.md) - 기술 검토 및 분석
- [구현_가이드_배포_워크플로우.md](./구현_가이드_배포_워크플로우.md) - 배포 프로세스

### 8.3 트러블슈팅

**문제: Kakao API 401 Unauthorized**
```bash
# .env 파일에 REST API 키 확인
echo $KAKAO_REST_API_KEY

# 플랫폼 도메인 등록 확인
# https://developers.kakao.com/console/app
```

**문제: 백그라운드 위치 추적 중단**
```typescript
// Android: 배터리 최적화 제외 요청
import * as IntentLauncher from 'expo-intent-launcher';

await IntentLauncher.startActivityAsync(
  IntentLauncher.ActivityAction.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
);
```

**문제: Geofencing 동작 안 함**
```typescript
// iOS: Info.plist에 권한 설명 추가
<key>NSLocationAlwaysUsageDescription</key>
<string>배송 중 자동 체크인을 위해 위치 권한이 필요합니다</string>
```

---

**작성 완료일**: 2025-10-19
**작성자**: Claude Code Assistant
**총 예상 개발 기간**: 26일 (약 1개월)
