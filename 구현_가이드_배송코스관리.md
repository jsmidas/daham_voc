# ë°°ì†¡ì½”ìŠ¤ ê´€ë¦¬ ì‹œìŠ¤í…œ - êµ¬í˜„ ê°€ì´ë“œ

> **ì‘ì„±ì¼**: 2025-10-19
> **ëª©ì **: ë°°ì†¡ì½”ìŠ¤ ê´€ë¦¬ ê¸°ëŠ¥ì„ ë‹¨ê³„ë³„ë¡œ êµ¬í˜„í•˜ê¸° ìœ„í•œ ìƒì„¸ ê°€ì´ë“œ
> **ì˜ˆìƒ ê¸°ê°„**: 26ì¼ (ì•½ 1ê°œì›”)

---

## ğŸ“‹ ëª©ì°¨

1. [í”„ë¡œì íŠ¸ ê°œìš”](#1-í”„ë¡œì íŠ¸-ê°œìš”)
2. [Phase 1: ê¸°ë³¸ ì½”ìŠ¤ ê´€ë¦¬ (2ì£¼)](#2-phase-1-ê¸°ë³¸-ì½”ìŠ¤-ê´€ë¦¬)
3. [Phase 2: ëª¨ë°”ì¼ ë°°ì†¡ ê¸°ëŠ¥ (2ì£¼)](#3-phase-2-ëª¨ë°”ì¼-ë°°ì†¡-ê¸°ëŠ¥)
4. [Phase 3: GPS ìë™ ì¶”ì  (1ì£¼)](#4-phase-3-gps-ìë™-ì¶”ì )
5. [Phase 4: ê²½ë¡œ ìµœì í™” (1ì£¼)](#5-phase-4-ê²½ë¡œ-ìµœì í™”)
6. [í…ŒìŠ¤íŠ¸ ê³„íš](#6-í…ŒìŠ¤íŠ¸-ê³„íš)
7. [ë°°í¬ ì²´í¬ë¦¬ìŠ¤íŠ¸](#7-ë°°í¬-ì²´í¬ë¦¬ìŠ¤íŠ¸)

---

## 1. í”„ë¡œì íŠ¸ ê°œìš”

### 1.1 ìš”êµ¬ì‚¬í•­ ìš”ì•½

| ë²ˆí˜¸ | ìš”êµ¬ì‚¬í•­ | ìš°ì„ ìˆœìœ„ |
|------|---------|---------|
| 1 | ì‚¬ì—…ì¥ì— ë²ˆí˜¸ ë¶€ì—¬ ë° ì½”ìŠ¤ë³„ ìˆœì„œ ê´€ë¦¬ | ë†’ìŒ |
| 2 | A, B, C, D ë“± ë°°ì†¡ ì½”ìŠ¤ ìƒì„± | ë†’ìŒ |
| 3 | ë°°ì†¡ê¸°ì‚¬ë³„ ì½”ìŠ¤ ë°°ì • ë° ì¡°íšŒ | ë†’ìŒ |
| 4 | GPS ê¸°ë°˜ ë„ì°©/ì¶œë°œ ì‹œê°„ ìë™ ê¸°ë¡ | ì¤‘ê°„ |
| 5 | ì‚¬ì—…ì¥ ê°„ ì´ë™ ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜ | ì¤‘ê°„ |
| 6 | ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ | ë‚®ìŒ |

### 1.2 ê¸°ìˆ  ìŠ¤íƒ

**ë°±ì—”ë“œ:**
- TypeScript + Express.js
- Prisma ORM
- PostgreSQL
- Kakao Mobility API

**í”„ë¡ íŠ¸ì—”ë“œ (ì›¹ ê´€ë¦¬ì):**
- React + TypeScript
- Ant Design
- Kakao Map SDK
- React Query

**ëª¨ë°”ì¼:**
- React Native (Expo)
- Expo Location
- Expo Task Manager
- React Navigation

### 1.3 ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡° (ì‹ ê·œ ëª¨ë¸)

```prisma
// DeliveryRoute: ë°°ì†¡ ì½”ìŠ¤
// DeliveryRouteStop: ì½”ìŠ¤ ë‚´ ì‚¬ì—…ì¥ ìˆœì„œ
// DeliveryAssignment: ê¸°ì‚¬-ì½”ìŠ¤ ë°°ì •
// DeliveryLog: ë°°ì†¡ ê¸°ë¡
```

---

## 2. Phase 1: ê¸°ë³¸ ì½”ìŠ¤ ê´€ë¦¬

**ê¸°ê°„**: 10ì¼
**ëª©í‘œ**: ì›¹ ê´€ë¦¬ìì—ì„œ ë°°ì†¡ ì½”ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ì‚¬ì—…ì¥ì„ ë°°ì •

### 2.1 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì¶”ê°€

#### Step 1-1: Prisma Schema ì—…ë°ì´íŠ¸

**íŒŒì¼**: `backend/prisma/schema.prisma`

```prisma
// ==================== ë°°ì†¡ ì½”ìŠ¤ ê´€ë¦¬ ====================

// ë°°ì†¡ ì½”ìŠ¤ (Aì½”ìŠ¤, Bì½”ìŠ¤ ë“±)
model DeliveryRoute {
  id          String   @id @default(uuid())
  name        String   @unique           // "Aì½”ìŠ¤", "Bì½”ìŠ¤"
  code        String   @unique           // "A", "B", "C"
  division    Division                   // HQ, YEONGNAM
  description String?                    // ì½”ìŠ¤ ì„¤ëª…
  color       String   @default("#1890ff") // ì½”ìŠ¤ ìƒ‰ìƒ (ì§€ë„ í‘œì‹œìš©)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  // Relations
  routeStops      DeliveryRouteStop[]    // ì½”ìŠ¤ ë‚´ ì‚¬ì—…ì¥ ëª©ë¡
  assignments     DeliveryAssignment[]   // ê¸°ì‚¬ ë°°ì •
  deliveryLogs    DeliveryLog[]          // ë°°ì†¡ ê¸°ë¡

  @@index([division])
  @@index([isActive])
  @@map("delivery_routes")
}

// ì½”ìŠ¤ ë‚´ ì‚¬ì—…ì¥ ìˆœì„œ
model DeliveryRouteStop {
  id                String   @id @default(uuid())
  routeId           String
  siteId            String
  stopNumber        Int                   // ë°©ë¬¸ ìˆœì„œ (1, 2, 3...)
  estimatedArrival  String?               // ì˜ˆìƒ ë„ì°© ì‹œê°„ "09:30"
  estimatedDuration Int?                  // ì˜ˆìƒ ì†Œìš” ì‹œê°„ (ë¶„)
  notes             String?               // íŠ¹ì´ì‚¬í•­
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  route    DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  site     Site          @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@unique([routeId, siteId])      // ê°™ì€ ì½”ìŠ¤ì— ì¤‘ë³µ ì‚¬ì—…ì¥ ë°©ì§€
  @@unique([routeId, stopNumber])  // ê°™ì€ ì½”ìŠ¤ì— ì¤‘ë³µ ìˆœì„œ ë°©ì§€
  @@index([routeId, stopNumber])
  @@index([siteId])
  @@map("delivery_route_stops")
}

// ê¸°ì‚¬-ì½”ìŠ¤ ë°°ì •
model DeliveryAssignment {
  id         String    @id @default(uuid())
  routeId    String
  driverId   String                        // User.id (DELIVERY_DRIVER)
  assignedAt DateTime  @default(now())
  removedAt  DateTime?
  isActive   Boolean   @default(true)

  // Relations
  route  DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  driver User          @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@unique([routeId, driverId])
  @@index([driverId])
  @@index([routeId])
  @@map("delivery_assignments")
}

// ë°°ì†¡ ê¸°ë¡
model DeliveryLog {
  id              String          @id @default(uuid())
  routeId         String
  siteId          String
  driverId        String
  deliveryDate    DateTime        @db.Date       // ë°°ì†¡ ë‚ ì§œ
  stopNumber      Int                            // ë°©ë¬¸ ìˆœì„œ

  // GPS ë° ì‹œê°„ ì •ë³´
  arrivedAt       DateTime?                      // ì‹¤ì œ ë„ì°© ì‹œê°„
  departedAt      DateTime?                      // ì¶œë°œ ì‹œê°„
  arrivalLat      Float?                         // ë„ì°© ì‹œ GPS
  arrivalLng      Float?
  departureLat    Float?                         // ì¶œë°œ ì‹œ GPS
  departureLng    Float?

  // ë°°ì†¡ ìƒíƒœ
  status          DeliveryStatus  @default(PENDING)
  actualDuration  Int?                           // ì‹¤ì œ ì†Œìš” ì‹œê°„ (ë¶„)
  distanceKm      Float?                         // ì´ë™ ê±°ë¦¬

  // ë©”ëª¨
  note            String?
  issueReported   Boolean         @default(false)
  issueDetail     String?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  route  DeliveryRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)
  site   Site          @relation(fields: [siteId], references: [id], onDelete: Cascade)
  driver User          @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@unique([routeId, siteId, deliveryDate])   // í•˜ë£¨ì— í•œ ë²ˆë§Œ ë°°ì†¡
  @@index([deliveryDate])
  @@index([driverId, deliveryDate])
  @@index([routeId, deliveryDate])
  @@index([status])
  @@map("delivery_logs")
}

enum DeliveryStatus {
  PENDING      // ëŒ€ê¸°
  IN_TRANSIT   // ì´ë™ ì¤‘
  ARRIVED      // ë„ì°©
  COMPLETED    // ì™„ë£Œ
  DELAYED      // ì§€ì—°
  ISSUE        // ë¬¸ì œ ë°œìƒ
}

// Site ëª¨ë¸ì— ì¶”ê°€
model Site {
  // ... ê¸°ì¡´ í•„ë“œ

  // ìƒˆë¡œ ì¶”ê°€
  routeStops   DeliveryRouteStop[]  // ì½”ìŠ¤ ì •ë¥˜ì¥
  deliveryLogs DeliveryLog[]        // ë°°ì†¡ ê¸°ë¡
}

// User ëª¨ë¸ì— ì¶”ê°€
model User {
  // ... ê¸°ì¡´ í•„ë“œ

  // ìƒˆë¡œ ì¶”ê°€
  deliveryAssignments DeliveryAssignment[]  // ë°°ì†¡ ê¸°ì‚¬ ë°°ì •
  deliveryLogs        DeliveryLog[]         // ë°°ì†¡ ê¸°ë¡
}
```

#### Step 1-2: ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„± ë° ì ìš©

```bash
# ë¡œì»¬ ê°œë°œ í™˜ê²½ì—ì„œ
cd backend

# ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„±
npx prisma migrate dev --name add_delivery_route_system

# Prisma Client ì¬ìƒì„±
npx prisma generate

# Git Commit
git add prisma/
git commit -m "feat: Add delivery route management database schema

- Add DeliveryRoute, DeliveryRouteStop, DeliveryAssignment, DeliveryLog models
- Add DeliveryStatus enum
- Update Site and User models with delivery relations"

git push
```

#### Step 1-3: í”„ë¡œë•ì…˜ ë°°í¬

```bash
ssh root@165.246.44.4
cd ~/daham_voc

# ë°±ì—… ë¨¼ì €!
pg_dump -U daham_user daham_voc > ~/backups/before_delivery_routes_$(date +%Y%m%d).sql

# ì½”ë“œ ì—…ë°ì´íŠ¸
git pull

# ë§ˆì´ê·¸ë ˆì´ì…˜ ì ìš©
cd backend
npx prisma migrate deploy
npx prisma generate

# ì¬ì‹œì‘
npm run build
pm2 restart daham-voc-api

# í™•ì¸
pm2 logs daham-voc-api --lines 20
```

---

### 2.2 ë°±ì—”ë“œ API êµ¬í˜„

#### Step 2-1: Types ì •ì˜

**íŒŒì¼**: `backend/src/types/delivery-route.types.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { DeliveryStatus } from '@prisma/client';

/**
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„± ìš”ì²­
 */
export interface CreateDeliveryRouteDto {
  name: string;           // "Aì½”ìŠ¤"
  code: string;           // "A"
  division: 'HQ' | 'YEONGNAM';
  description?: string;
  color?: string;
}

/**
 * ë°°ì†¡ ì½”ìŠ¤ ì—…ë°ì´íŠ¸ ìš”ì²­
 */
export interface UpdateDeliveryRouteDto {
  name?: string;
  description?: string;
  color?: string;
  isActive?: boolean;
}

/**
 * ì½”ìŠ¤ì— ì‚¬ì—…ì¥ ì¶”ê°€ ìš”ì²­
 */
export interface AddSiteToRouteDto {
  siteId: string;
  stopNumber: number;
  estimatedArrival?: string;  // "09:30"
  estimatedDuration?: number;
  notes?: string;
}

/**
 * ì½”ìŠ¤ ì‚¬ì—…ì¥ ìˆœì„œ ì—…ë°ì´íŠ¸
 */
export interface UpdateRouteStopsDto {
  stops: Array<{
    id: string;
    stopNumber: number;
  }>;
}

/**
 * ê¸°ì‚¬ ë°°ì • ìš”ì²­
 */
export interface AssignDriverDto {
  routeId: string;
  driverIds: string[];
}

/**
 * ë°°ì†¡ ê¸°ë¡ ìƒì„±
 */
export interface CreateDeliveryLogDto {
  routeId: string;
  siteId: string;
  stopNumber: number;
  arrivedAt?: Date;
  arrivalLat?: number;
  arrivalLng?: number;
  status: DeliveryStatus;
  note?: string;
}

/**
 * ë°°ì†¡ ì½”ìŠ¤ ì‘ë‹µ
 */
export interface DeliveryRouteResponse {
  id: string;
  name: string;
  code: string;
  division: string;
  description?: string;
  color: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  stopsCount: number;
  assignedDrivers: Array<{
    id: string;
    name: string;
    phone: string;
  }>;
}

/**
 * ì½”ìŠ¤ ìƒì„¸ (ì‚¬ì—…ì¥ í¬í•¨)
 */
export interface DeliveryRouteDetailResponse extends DeliveryRouteResponse {
  stops: Array<{
    id: string;
    stopNumber: number;
    estimatedArrival?: string;
    estimatedDuration?: number;
    notes?: string;
    site: {
      id: string;
      name: string;
      address: string;
      latitude: number;
      longitude: number;
      type: string;
    };
  }>;
}
```

#### Step 2-2: Validators

**íŒŒì¼**: `backend/src/validators/delivery-route.validator.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import Joi from 'joi';

/**
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„± ê²€ì¦
 */
export const createDeliveryRouteSchema = Joi.object({
  name: Joi.string().min(2).max(50).required().messages({
    'string.min': 'ì½”ìŠ¤ ì´ë¦„ì€ ìµœì†Œ 2ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤',
    'string.max': 'ì½”ìŠ¤ ì´ë¦„ì€ ìµœëŒ€ 50ìê¹Œì§€ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤',
    'any.required': 'ì½”ìŠ¤ ì´ë¦„ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤',
  }),
  code: Joi.string().min(1).max(10).required().messages({
    'string.min': 'ì½”ìŠ¤ ì½”ë“œëŠ” ìµœì†Œ 1ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤',
    'string.max': 'ì½”ìŠ¤ ì½”ë“œëŠ” ìµœëŒ€ 10ìê¹Œì§€ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤',
    'any.required': 'ì½”ìŠ¤ ì½”ë“œëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤',
  }),
  division: Joi.string().valid('HQ', 'YEONGNAM').required().messages({
    'any.only': 'ìœ íš¨í•œ ë¶€ë¬¸ì„ ì„ íƒí•´ì£¼ì„¸ìš” (ë³¸ì‚¬/ì˜ë‚¨ì§€ì‚¬)',
    'any.required': 'ë¶€ë¬¸ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤',
  }),
  description: Joi.string().max(500).optional().allow('').messages({
    'string.max': 'ì„¤ëª…ì€ ìµœëŒ€ 500ìê¹Œì§€ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤',
  }),
  color: Joi.string().pattern(/^#[0-9A-Fa-f]{6}$/).optional().messages({
    'string.pattern.base': 'ì˜¬ë°”ë¥¸ ìƒ‰ìƒ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: #1890ff)',
  }),
});

/**
 * ë°°ì†¡ ì½”ìŠ¤ ìˆ˜ì • ê²€ì¦
 */
export const updateDeliveryRouteSchema = Joi.object({
  name: Joi.string().min(2).max(50).optional(),
  description: Joi.string().max(500).optional().allow(''),
  color: Joi.string().pattern(/^#[0-9A-Fa-f]{6}$/).optional(),
  isActive: Joi.boolean().optional(),
});

/**
 * ì½”ìŠ¤ì— ì‚¬ì—…ì¥ ì¶”ê°€ ê²€ì¦
 */
export const addSiteToRouteSchema = Joi.object({
  siteId: Joi.string().uuid().required().messages({
    'string.uuid': 'ìœ íš¨í•œ ì‚¬ì—…ì¥ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”',
    'any.required': 'ì‚¬ì—…ì¥ IDëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤',
  }),
  stopNumber: Joi.number().min(1).required().messages({
    'number.min': 'ë°©ë¬¸ ìˆœì„œëŠ” 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤',
    'any.required': 'ë°©ë¬¸ ìˆœì„œëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤',
  }),
  estimatedArrival: Joi.string().pattern(/^([01]\d|2[0-3]):([0-5]\d)$/).optional().messages({
    'string.pattern.base': 'ì˜¬ë°”ë¥¸ ì‹œê°„ í˜•ì‹ì„ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: 09:30)',
  }),
  estimatedDuration: Joi.number().min(0).optional().messages({
    'number.min': 'ì˜ˆìƒ ì†Œìš” ì‹œê°„ì€ 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤',
  }),
  notes: Joi.string().max(500).optional().allow(''),
});

/**
 * ì½”ìŠ¤ ì‚¬ì—…ì¥ ìˆœì„œ ì—…ë°ì´íŠ¸ ê²€ì¦
 */
export const updateRouteStopsSchema = Joi.object({
  stops: Joi.array()
    .items(
      Joi.object({
        id: Joi.string().uuid().required(),
        stopNumber: Joi.number().min(1).required(),
      })
    )
    .min(1)
    .required()
    .messages({
      'array.min': 'ìµœì†Œ 1ê°œ ì´ìƒì˜ ì •ë¥˜ì¥ì´ í•„ìš”í•©ë‹ˆë‹¤',
      'any.required': 'ì •ë¥˜ì¥ ëª©ë¡ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤',
    }),
});

/**
 * ê¸°ì‚¬ ë°°ì • ê²€ì¦
 */
export const assignDriverSchema = Joi.object({
  routeId: Joi.string().uuid().required(),
  driverIds: Joi.array().items(Joi.string().uuid()).min(1).required().messages({
    'array.min': 'ìµœì†Œ 1ëª… ì´ìƒì˜ ê¸°ì‚¬ë¥¼ ë°°ì •í•´ì•¼ í•©ë‹ˆë‹¤',
  }),
});

/**
 * ë°°ì†¡ ê¸°ë¡ ìƒì„± ê²€ì¦
 */
export const createDeliveryLogSchema = Joi.object({
  routeId: Joi.string().uuid().required(),
  siteId: Joi.string().uuid().required(),
  stopNumber: Joi.number().min(1).required(),
  arrivedAt: Joi.date().iso().optional(),
  arrivalLat: Joi.number().min(-90).max(90).optional(),
  arrivalLng: Joi.number().min(-180).max(180).optional(),
  status: Joi.string()
    .valid('PENDING', 'IN_TRANSIT', 'ARRIVED', 'COMPLETED', 'DELAYED', 'ISSUE')
    .required(),
  note: Joi.string().max(500).optional().allow(''),
});

/**
 * ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ê²€ì¦
 */
export const getDeliveryRoutesQuerySchema = Joi.object({
  division: Joi.string().valid('HQ', 'YEONGNAM').optional(),
  isActive: Joi.boolean().optional(),
  search: Joi.string().max(100).optional(),
});
```

#### Step 2-3: Service Layer

**íŒŒì¼**: `backend/src/services/delivery-route.service.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { PrismaClient, Prisma } from '@prisma/client';
import {
  CreateDeliveryRouteDto,
  UpdateDeliveryRouteDto,
  AddSiteToRouteDto,
  UpdateRouteStopsDto,
  AssignDriverDto,
  DeliveryRouteResponse,
  DeliveryRouteDetailResponse,
} from '../types/delivery-route.types';

const prisma = new PrismaClient();

export class DeliveryRouteService {
  /**
   * ë°°ì†¡ ì½”ìŠ¤ ëª©ë¡ ì¡°íšŒ
   */
  async getDeliveryRoutes(filters: {
    division?: 'HQ' | 'YEONGNAM';
    isActive?: boolean;
    search?: string;
  }): Promise<DeliveryRouteResponse[]> {
    const where: Prisma.DeliveryRouteWhereInput = {
      deletedAt: null,
    };

    if (filters.division) {
      where.division = filters.division;
    }

    if (filters.isActive !== undefined) {
      where.isActive = filters.isActive;
    }

    if (filters.search) {
      where.OR = [
        { name: { contains: filters.search, mode: 'insensitive' } },
        { code: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    const routes = await prisma.deliveryRoute.findMany({
      where,
      include: {
        routeStops: {
          where: { isActive: true },
        },
        assignments: {
          where: { isActive: true },
          include: {
            driver: {
              select: {
                id: true,
                name: true,
                phone: true,
              },
            },
          },
        },
      },
      orderBy: [{ division: 'asc' }, { code: 'asc' }],
    });

    return routes.map((route) => ({
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: route.routeStops.length,
      assignedDrivers: route.assignments.map((a) => a.driver),
    }));
  }

  /**
   * ë°°ì†¡ ì½”ìŠ¤ ìƒì„¸ ì¡°íšŒ
   */
  async getDeliveryRouteById(id: string): Promise<DeliveryRouteDetailResponse> {
    const route = await prisma.deliveryRoute.findUnique({
      where: { id },
      include: {
        routeStops: {
          where: { isActive: true },
          include: {
            site: {
              select: {
                id: true,
                name: true,
                address: true,
                latitude: true,
                longitude: true,
                type: true,
              },
            },
          },
          orderBy: { stopNumber: 'asc' },
        },
        assignments: {
          where: { isActive: true },
          include: {
            driver: {
              select: {
                id: true,
                name: true,
                phone: true,
              },
            },
          },
        },
      },
    });

    if (!route || route.deletedAt) {
      throw new Error('ë°°ì†¡ ì½”ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }

    return {
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: route.routeStops.length,
      assignedDrivers: route.assignments.map((a) => a.driver),
      stops: route.routeStops.map((stop) => ({
        id: stop.id,
        stopNumber: stop.stopNumber,
        estimatedArrival: stop.estimatedArrival || undefined,
        estimatedDuration: stop.estimatedDuration || undefined,
        notes: stop.notes || undefined,
        site: stop.site,
      })),
    };
  }

  /**
   * ë°°ì†¡ ì½”ìŠ¤ ìƒì„±
   */
  async createDeliveryRoute(data: CreateDeliveryRouteDto): Promise<DeliveryRouteResponse> {
    // ì¤‘ë³µ ê²€ì‚¬
    const existingRoute = await prisma.deliveryRoute.findFirst({
      where: {
        OR: [{ name: data.name }, { code: data.code }],
        deletedAt: null,
      },
    });

    if (existingRoute) {
      throw new Error('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì½”ìŠ¤ëª… ë˜ëŠ” ì½”ë“œì…ë‹ˆë‹¤');
    }

    const route = await prisma.deliveryRoute.create({
      data: {
        name: data.name,
        code: data.code,
        division: data.division,
        description: data.description,
        color: data.color || '#1890ff',
      },
      include: {
        routeStops: true,
        assignments: {
          include: {
            driver: {
              select: { id: true, name: true, phone: true },
            },
          },
        },
      },
    });

    return {
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: 0,
      assignedDrivers: [],
    };
  }

  /**
   * ë°°ì†¡ ì½”ìŠ¤ ìˆ˜ì •
   */
  async updateDeliveryRoute(
    id: string,
    data: UpdateDeliveryRouteDto
  ): Promise<DeliveryRouteResponse> {
    const route = await prisma.deliveryRoute.update({
      where: { id },
      data,
      include: {
        routeStops: {
          where: { isActive: true },
        },
        assignments: {
          where: { isActive: true },
          include: {
            driver: {
              select: { id: true, name: true, phone: true },
            },
          },
        },
      },
    });

    return {
      id: route.id,
      name: route.name,
      code: route.code,
      division: route.division,
      description: route.description || undefined,
      color: route.color,
      isActive: route.isActive,
      createdAt: route.createdAt,
      updatedAt: route.updatedAt,
      stopsCount: route.routeStops.length,
      assignedDrivers: route.assignments.map((a) => a.driver),
    };
  }

  /**
   * ë°°ì†¡ ì½”ìŠ¤ ì‚­ì œ (ì†Œí”„íŠ¸ ì‚­ì œ)
   */
  async deleteDeliveryRoute(id: string): Promise<void> {
    await prisma.deliveryRoute.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        isActive: false,
      },
    });
  }

  /**
   * ì½”ìŠ¤ì— ì‚¬ì—…ì¥ ì¶”ê°€
   */
  async addSiteToRoute(routeId: string, data: AddSiteToRouteDto): Promise<void> {
    // ì½”ìŠ¤ ì¡´ì¬ í™•ì¸
    const route = await prisma.deliveryRoute.findUnique({
      where: { id: routeId },
    });

    if (!route || route.deletedAt) {
      throw new Error('ë°°ì†¡ ì½”ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }

    // ì‚¬ì—…ì¥ ì¡´ì¬ í™•ì¸
    const site = await prisma.site.findUnique({
      where: { id: data.siteId },
    });

    if (!site || site.deletedAt) {
      throw new Error('ì‚¬ì—…ì¥ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }

    // ì¤‘ë³µ í™•ì¸
    const existing = await prisma.deliveryRouteStop.findUnique({
      where: {
        routeId_siteId: {
          routeId,
          siteId: data.siteId,
        },
      },
    });

    if (existing) {
      throw new Error('ì´ë¯¸ í•´ë‹¹ ì½”ìŠ¤ì— ë“±ë¡ëœ ì‚¬ì—…ì¥ì…ë‹ˆë‹¤');
    }

    // ìˆœì„œ ì¤‘ë³µ í™•ì¸
    const stopNumberExists = await prisma.deliveryRouteStop.findUnique({
      where: {
        routeId_stopNumber: {
          routeId,
          stopNumber: data.stopNumber,
        },
      },
    });

    if (stopNumberExists) {
      throw new Error('ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ìˆœì„œ ë²ˆí˜¸ì…ë‹ˆë‹¤');
    }

    await prisma.deliveryRouteStop.create({
      data: {
        routeId,
        siteId: data.siteId,
        stopNumber: data.stopNumber,
        estimatedArrival: data.estimatedArrival,
        estimatedDuration: data.estimatedDuration,
        notes: data.notes,
      },
    });
  }

  /**
   * ì½”ìŠ¤ì—ì„œ ì‚¬ì—…ì¥ ì œê±°
   */
  async removeSiteFromRoute(routeId: string, siteId: string): Promise<void> {
    await prisma.deliveryRouteStop.update({
      where: {
        routeId_siteId: {
          routeId,
          siteId,
        },
      },
      data: {
        isActive: false,
      },
    });
  }

  /**
   * ì½”ìŠ¤ ì‚¬ì—…ì¥ ìˆœì„œ ì¼ê´„ ì—…ë°ì´íŠ¸
   */
  async updateRouteStops(routeId: string, data: UpdateRouteStopsDto): Promise<void> {
    // íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì¼ê´„ ì—…ë°ì´íŠ¸
    await prisma.$transaction(
      data.stops.map((stop) =>
        prisma.deliveryRouteStop.update({
          where: { id: stop.id },
          data: { stopNumber: stop.stopNumber },
        })
      )
    );
  }

  /**
   * ê¸°ì‚¬ ë°°ì •
   */
  async assignDrivers(data: AssignDriverDto): Promise<void> {
    const { routeId, driverIds } = data;

    // ê¸°ì¡´ ë°°ì • ë¹„í™œì„±í™”
    await prisma.deliveryAssignment.updateMany({
      where: {
        routeId,
        isActive: true,
      },
      data: {
        isActive: false,
        removedAt: new Date(),
      },
    });

    // ìƒˆ ë°°ì • ìƒì„±
    await prisma.deliveryAssignment.createMany({
      data: driverIds.map((driverId) => ({
        routeId,
        driverId,
      })),
      skipDuplicates: true,
    });
  }

  /**
   * ë°°ì†¡ê¸°ì‚¬ì˜ ë°°ì •ëœ ì½”ìŠ¤ ì¡°íšŒ
   */
  async getDriverRoutes(driverId: string): Promise<DeliveryRouteDetailResponse[]> {
    const assignments = await prisma.deliveryAssignment.findMany({
      where: {
        driverId,
        isActive: true,
      },
      include: {
        route: {
          include: {
            routeStops: {
              where: { isActive: true },
              include: {
                site: {
                  select: {
                    id: true,
                    name: true,
                    address: true,
                    latitude: true,
                    longitude: true,
                    type: true,
                  },
                },
              },
              orderBy: { stopNumber: 'asc' },
            },
            assignments: {
              where: { isActive: true },
              include: {
                driver: {
                  select: { id: true, name: true, phone: true },
                },
              },
            },
          },
        },
      },
    });

    return assignments.map((assignment) => {
      const route = assignment.route;
      return {
        id: route.id,
        name: route.name,
        code: route.code,
        division: route.division,
        description: route.description || undefined,
        color: route.color,
        isActive: route.isActive,
        createdAt: route.createdAt,
        updatedAt: route.updatedAt,
        stopsCount: route.routeStops.length,
        assignedDrivers: route.assignments.map((a) => a.driver),
        stops: route.routeStops.map((stop) => ({
          id: stop.id,
          stopNumber: stop.stopNumber,
          estimatedArrival: stop.estimatedArrival || undefined,
          estimatedDuration: stop.estimatedDuration || undefined,
          notes: stop.notes || undefined,
          site: stop.site,
        })),
      };
    });
  }
}
```

#### Step 2-4: Controller

**íŒŒì¼**: `backend/src/controllers/delivery-route.controller.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { Request, Response, NextFunction } from 'express';
import { DeliveryRouteService } from '../services/delivery-route.service';

const deliveryRouteService = new DeliveryRouteService();

/**
 * GET /api/v1/delivery-routes
 * ë°°ì†¡ ì½”ìŠ¤ ëª©ë¡ ì¡°íšŒ
 */
export async function getDeliveryRoutes(req: Request, res: Response, next: NextFunction) {
  try {
    const { division, isActive, search } = req.query;

    const routes = await deliveryRouteService.getDeliveryRoutes({
      division: division as 'HQ' | 'YEONGNAM' | undefined,
      isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined,
      search: search as string | undefined,
    });

    res.json({
      success: true,
      data: routes,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-routes/:id
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„¸ ì¡°íšŒ
 */
export async function getDeliveryRouteById(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const route = await deliveryRouteService.getDeliveryRouteById(id);

    res.json({
      success: true,
      data: route,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„±
 */
export async function createDeliveryRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const route = await deliveryRouteService.createDeliveryRoute(req.body);

    res.status(201).json({
      success: true,
      data: route,
      message: 'ë°°ì†¡ ì½”ìŠ¤ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * PATCH /api/v1/delivery-routes/:id
 * ë°°ì†¡ ì½”ìŠ¤ ìˆ˜ì •
 */
export async function updateDeliveryRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const route = await deliveryRouteService.updateDeliveryRoute(id, req.body);

    res.json({
      success: true,
      data: route,
      message: 'ë°°ì†¡ ì½”ìŠ¤ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * DELETE /api/v1/delivery-routes/:id
 * ë°°ì†¡ ì½”ìŠ¤ ì‚­ì œ
 */
export async function deleteDeliveryRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.deleteDeliveryRoute(id);

    res.json({
      success: true,
      message: 'ë°°ì†¡ ì½”ìŠ¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes/:id/stops
 * ì½”ìŠ¤ì— ì‚¬ì—…ì¥ ì¶”ê°€
 */
export async function addSiteToRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.addSiteToRoute(id, req.body);

    res.status(201).json({
      success: true,
      message: 'ì‚¬ì—…ì¥ì´ ì½”ìŠ¤ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * DELETE /api/v1/delivery-routes/:routeId/stops/:siteId
 * ì½”ìŠ¤ì—ì„œ ì‚¬ì—…ì¥ ì œê±°
 */
export async function removeSiteFromRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { routeId, siteId } = req.params;
    await deliveryRouteService.removeSiteFromRoute(routeId, siteId);

    res.json({
      success: true,
      message: 'ì‚¬ì—…ì¥ì´ ì½”ìŠ¤ì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * PUT /api/v1/delivery-routes/:id/stops/reorder
 * ì½”ìŠ¤ ì‚¬ì—…ì¥ ìˆœì„œ ë³€ê²½
 */
export async function updateRouteStops(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.updateRouteStops(id, req.body);

    res.json({
      success: true,
      message: 'ì‚¬ì—…ì¥ ìˆœì„œê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes/:id/assign-drivers
 * ê¸°ì‚¬ ë°°ì •
 */
export async function assignDrivers(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    await deliveryRouteService.assignDrivers({
      routeId: id,
      driverIds: req.body.driverIds,
    });

    res.json({
      success: true,
      message: 'ê¸°ì‚¬ê°€ ë°°ì •ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-routes/my-routes
 * ë‚´ ë°°ì†¡ ì½”ìŠ¤ ì¡°íšŒ (ë°°ì†¡ê¸°ì‚¬ìš©)
 */
export async function getMyRoutes(req: Request, res: Response, next: NextFunction) {
  try {
    const userId = req.user?.id; // JWTì—ì„œ ì¶”ì¶œ

    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤',
      });
    }

    const routes = await deliveryRouteService.getDriverRoutes(userId);

    res.json({
      success: true,
      data: routes,
    });
  } catch (error) {
    next(error);
  }
}
```

#### Step 2-5: Routes

**íŒŒì¼**: `backend/src/routes/delivery-route.routes.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { Router } from 'express';
import * as deliveryRouteController from '../controllers/delivery-route.controller';
import { authenticate } from '../middleware/auth.middleware';
import { authorize } from '../middleware/role.middleware';
import { validate } from '../middleware/validation.middleware';
import {
  createDeliveryRouteSchema,
  updateDeliveryRouteSchema,
  addSiteToRouteSchema,
  updateRouteStopsSchema,
  assignDriverSchema,
  getDeliveryRoutesQuerySchema,
} from '../validators/delivery-route.validator';

const router = Router();

// ëª¨ë“  ë¼ìš°íŠ¸ëŠ” ì¸ì¦ í•„ìš”
router.use(authenticate);

/**
 * GET /api/v1/delivery-routes
 * ë°°ì†¡ ì½”ìŠ¤ ëª©ë¡ ì¡°íšŒ
 * ê¶Œí•œ: DELIVERY_DRIVER, MANAGER, ADMIN, SUPER_ADMIN
 */
router.get(
  '/',
  validate({ query: getDeliveryRoutesQuerySchema }),
  deliveryRouteController.getDeliveryRoutes
);

/**
 * GET /api/v1/delivery-routes/my-routes
 * ë‚´ ë°°ì†¡ ì½”ìŠ¤ ì¡°íšŒ (ë°°ì†¡ê¸°ì‚¬ìš©)
 * ê¶Œí•œ: DELIVERY_DRIVER
 */
router.get(
  '/my-routes',
  authorize(['DELIVERY_DRIVER']),
  deliveryRouteController.getMyRoutes
);

/**
 * GET /api/v1/delivery-routes/:id
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„¸ ì¡°íšŒ
 */
router.get('/:id', deliveryRouteController.getDeliveryRouteById);

/**
 * POST /api/v1/delivery-routes
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„±
 * ê¶Œí•œ: MANAGER, ADMIN, SUPER_ADMIN
 */
router.post(
  '/',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: createDeliveryRouteSchema }),
  deliveryRouteController.createDeliveryRoute
);

/**
 * PATCH /api/v1/delivery-routes/:id
 * ë°°ì†¡ ì½”ìŠ¤ ìˆ˜ì •
 */
router.patch(
  '/:id',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: updateDeliveryRouteSchema }),
  deliveryRouteController.updateDeliveryRoute
);

/**
 * DELETE /api/v1/delivery-routes/:id
 * ë°°ì†¡ ì½”ìŠ¤ ì‚­ì œ
 */
router.delete(
  '/:id',
  authorize(['ADMIN', 'SUPER_ADMIN']),
  deliveryRouteController.deleteDeliveryRoute
);

/**
 * POST /api/v1/delivery-routes/:id/stops
 * ì½”ìŠ¤ì— ì‚¬ì—…ì¥ ì¶”ê°€
 */
router.post(
  '/:id/stops',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: addSiteToRouteSchema }),
  deliveryRouteController.addSiteToRoute
);

/**
 * DELETE /api/v1/delivery-routes/:routeId/stops/:siteId
 * ì½”ìŠ¤ì—ì„œ ì‚¬ì—…ì¥ ì œê±°
 */
router.delete(
  '/:routeId/stops/:siteId',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  deliveryRouteController.removeSiteFromRoute
);

/**
 * PUT /api/v1/delivery-routes/:id/stops/reorder
 * ì½”ìŠ¤ ì‚¬ì—…ì¥ ìˆœì„œ ë³€ê²½
 */
router.put(
  '/:id/stops/reorder',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  validate({ body: updateRouteStopsSchema }),
  deliveryRouteController.updateRouteStops
);

/**
 * POST /api/v1/delivery-routes/:id/assign-drivers
 * ê¸°ì‚¬ ë°°ì •
 */
router.post(
  '/:id/assign-drivers',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  deliveryRouteController.assignDrivers
);

export default router;
```

#### Step 2-6: ë©”ì¸ ë¼ìš°í„° ë“±ë¡

**íŒŒì¼**: `backend/src/routes/index.ts` (ìˆ˜ì •)

```typescript
import deliveryRouteRoutes from './delivery-route.routes';

// ... ê¸°ì¡´ ì½”ë“œ

// ë¼ìš°íŠ¸ ë“±ë¡
app.use('/api/v1/delivery-routes', deliveryRouteRoutes);
```

#### Step 2-7: ë°±ì—”ë“œ í…ŒìŠ¤íŠ¸

```bash
# ë¡œì»¬ ë°±ì—”ë“œ ì‹¤í–‰
cd backend
npm run dev:clean

# ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ API í…ŒìŠ¤íŠ¸
# 1. ë¡œê·¸ì¸ (í† í° ë°›ê¸°)
curl -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"phone":"01012345678","password":"1234"}'

# TOKEN ì €ì¥
TOKEN="eyJhbGc..."

# 2. ë°°ì†¡ ì½”ìŠ¤ ìƒì„±
curl -X POST http://localhost:3000/api/v1/delivery-routes \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "name": "Aì½”ìŠ¤",
    "code": "A",
    "division": "HQ",
    "description": "ë³¸ì‚¬ ì˜¤ì „ ë°°ì†¡ ì½”ìŠ¤",
    "color": "#1890ff"
  }'

# 3. ì½”ìŠ¤ ëª©ë¡ ì¡°íšŒ
curl http://localhost:3000/api/v1/delivery-routes \
  -H "Authorization: Bearer $TOKEN"

# 4. ì½”ìŠ¤ì— ì‚¬ì—…ì¥ ì¶”ê°€
curl -X POST http://localhost:3000/api/v1/delivery-routes/{ROUTE_ID}/stops \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "siteId": "{SITE_ID}",
    "stopNumber": 1,
    "estimatedArrival": "09:00",
    "estimatedDuration": 15
  }'
```

---

### 2.3 í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„ (ì›¹ ê´€ë¦¬ì)

#### Step 3-1: Types ì •ì˜

**íŒŒì¼**: `web/src/types/delivery-route.ts` (ì‹ ê·œ ìƒì„±)

```typescript
export type Division = 'HQ' | 'YEONGNAM';
export type DeliveryStatus = 'PENDING' | 'IN_TRANSIT' | 'ARRIVED' | 'COMPLETED' | 'DELAYED' | 'ISSUE';

export interface DeliveryRoute {
  id: string;
  name: string;
  code: string;
  division: Division;
  description?: string;
  color: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  stopsCount: number;
  assignedDrivers: Array<{
    id: string;
    name: string;
    phone: string;
  }>;
}

export interface DeliveryRouteDetail extends DeliveryRoute {
  stops: DeliveryRouteStop[];
}

export interface DeliveryRouteStop {
  id: string;
  stopNumber: number;
  estimatedArrival?: string;
  estimatedDuration?: number;
  notes?: string;
  site: {
    id: string;
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    type: string;
  };
}

export interface CreateDeliveryRouteDto {
  name: string;
  code: string;
  division: Division;
  description?: string;
  color?: string;
}

export interface UpdateDeliveryRouteDto {
  name?: string;
  description?: string;
  color?: string;
  isActive?: boolean;
}

export interface AddSiteToRouteDto {
  siteId: string;
  stopNumber: number;
  estimatedArrival?: string;
  estimatedDuration?: number;
  notes?: string;
}
```

#### Step 3-2: API Client

**íŒŒì¼**: `web/src/api/delivery-route.api.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import axios from '../lib/axios';
import {
  DeliveryRoute,
  DeliveryRouteDetail,
  CreateDeliveryRouteDto,
  UpdateDeliveryRouteDto,
  AddSiteToRouteDto,
} from '../types/delivery-route';

/**
 * ë°°ì†¡ ì½”ìŠ¤ ëª©ë¡ ì¡°íšŒ
 */
export async function getDeliveryRoutes(params?: {
  division?: string;
  isActive?: boolean;
  search?: string;
}): Promise<DeliveryRoute[]> {
  const response = await axios.get('/delivery-routes', { params });
  return response.data.data;
}

/**
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„¸ ì¡°íšŒ
 */
export async function getDeliveryRouteById(id: string): Promise<DeliveryRouteDetail> {
  const response = await axios.get(`/delivery-routes/${id}`);
  return response.data.data;
}

/**
 * ë°°ì†¡ ì½”ìŠ¤ ìƒì„±
 */
export async function createDeliveryRoute(data: CreateDeliveryRouteDto): Promise<DeliveryRoute> {
  const response = await axios.post('/delivery-routes', data);
  return response.data.data;
}

/**
 * ë°°ì†¡ ì½”ìŠ¤ ìˆ˜ì •
 */
export async function updateDeliveryRoute(
  id: string,
  data: UpdateDeliveryRouteDto
): Promise<DeliveryRoute> {
  const response = await axios.patch(`/delivery-routes/${id}`, data);
  return response.data.data;
}

/**
 * ë°°ì†¡ ì½”ìŠ¤ ì‚­ì œ
 */
export async function deleteDeliveryRoute(id: string): Promise<void> {
  await axios.delete(`/delivery-routes/${id}`);
}

/**
 * ì½”ìŠ¤ì— ì‚¬ì—…ì¥ ì¶”ê°€
 */
export async function addSiteToRoute(routeId: string, data: AddSiteToRouteDto): Promise<void> {
  await axios.post(`/delivery-routes/${routeId}/stops`, data);
}

/**
 * ì½”ìŠ¤ì—ì„œ ì‚¬ì—…ì¥ ì œê±°
 */
export async function removeSiteFromRoute(routeId: string, siteId: string): Promise<void> {
  await axios.delete(`/delivery-routes/${routeId}/stops/${siteId}`);
}

/**
 * ì½”ìŠ¤ ì‚¬ì—…ì¥ ìˆœì„œ ë³€ê²½
 */
export async function updateRouteStops(
  routeId: string,
  stops: Array<{ id: string; stopNumber: number }>
): Promise<void> {
  await axios.put(`/delivery-routes/${routeId}/stops/reorder`, { stops });
}

/**
 * ê¸°ì‚¬ ë°°ì •
 */
export async function assignDrivers(routeId: string, driverIds: string[]): Promise<void> {
  await axios.post(`/delivery-routes/${routeId}/assign-drivers`, { driverIds });
}
```

#### Step 3-3: ì½”ìŠ¤ ëª©ë¡ í˜ì´ì§€

**íŒŒì¼**: `web/src/pages/delivery-route/DeliveryRouteListPage.tsx` (ì‹ ê·œ ìƒì„±)

```typescript
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';
import {
  Button,
  Table,
  Space,
  Tag,
  Input,
  Select,
  Card,
  Typography,
  Modal,
  message,
} from 'antd';
import {
  PlusOutlined,
  EditOutlined,
  DeleteOutlined,
  EyeOutlined,
  SearchOutlined,
} from '@ant-design/icons';
import { getDeliveryRoutes, deleteDeliveryRoute } from '../../api/delivery-route.api';
import { DeliveryRoute } from '../../types/delivery-route';
import CreateDeliveryRouteModal from '../../components/delivery-route/CreateDeliveryRouteModal';

const { Title } = Typography;

export default function DeliveryRouteListPage() {
  const navigate = useNavigate();
  const [search, setSearch] = useState('');
  const [division, setDivision] = useState<string | undefined>();
  const [isActive, setIsActive] = useState<boolean | undefined>(true);
  const [createModalOpen, setCreateModalOpen] = useState(false);

  // ë°°ì†¡ ì½”ìŠ¤ ëª©ë¡ ì¡°íšŒ
  const { data: routes, isLoading, refetch } = useQuery({
    queryKey: ['delivery-routes', { division, isActive, search }],
    queryFn: () => getDeliveryRoutes({ division, isActive, search }),
  });

  // ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleDelete = (route: DeliveryRoute) => {
    Modal.confirm({
      title: 'ë°°ì†¡ ì½”ìŠ¤ ì‚­ì œ',
      content: `"${route.name}"ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ê´€ë ¨ëœ ë°°ì†¡ ê¸°ë¡ì€ ìœ ì§€ë©ë‹ˆë‹¤.`,
      okText: 'ì‚­ì œ',
      okType: 'danger',
      cancelText: 'ì·¨ì†Œ',
      onOk: async () => {
        try {
          await deleteDeliveryRoute(route.id);
          message.success('ë°°ì†¡ ì½”ìŠ¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
          refetch();
        } catch (error) {
          message.error('ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
        }
      },
    });
  };

  // í…Œì´ë¸” ì»¬ëŸ¼ ì •ì˜
  const columns = [
    {
      title: 'ì½”ë“œ',
      dataIndex: 'code',
      key: 'code',
      width: 80,
      render: (code: string, record: DeliveryRoute) => (
        <Tag color={record.color}>{code}</Tag>
      ),
    },
    {
      title: 'ì½”ìŠ¤ëª…',
      dataIndex: 'name',
      key: 'name',
      render: (name: string) => <strong>{name}</strong>,
    },
    {
      title: 'ë¶€ë¬¸',
      dataIndex: 'division',
      key: 'division',
      width: 100,
      render: (division: string) => (
        <Tag color={division === 'HQ' ? 'blue' : 'green'}>
          {division === 'HQ' ? 'ë³¸ì‚¬' : 'ì˜ë‚¨ì§€ì‚¬'}
        </Tag>
      ),
    },
    {
      title: 'ì‚¬ì—…ì¥ ìˆ˜',
      dataIndex: 'stopsCount',
      key: 'stopsCount',
      width: 100,
      align: 'center' as const,
    },
    {
      title: 'ë°°ì • ê¸°ì‚¬',
      dataIndex: 'assignedDrivers',
      key: 'assignedDrivers',
      render: (drivers: Array<{ name: string }>) => (
        <Space size={4} wrap>
          {drivers.length > 0 ? (
            drivers.map((driver, i) => (
              <Tag key={i} color="purple">
                {driver.name}
              </Tag>
            ))
          ) : (
            <span style={{ color: '#999' }}>ë¯¸ë°°ì •</span>
          )}
        </Space>
      ),
    },
    {
      title: 'ìƒíƒœ',
      dataIndex: 'isActive',
      key: 'isActive',
      width: 80,
      render: (isActive: boolean) => (
        <Tag color={isActive ? 'success' : 'default'}>
          {isActive ? 'í™œì„±' : 'ë¹„í™œì„±'}
        </Tag>
      ),
    },
    {
      title: 'ì‘ì—…',
      key: 'actions',
      width: 150,
      render: (_: any, record: DeliveryRoute) => (
        <Space size="small">
          <Button
            type="link"
            icon={<EyeOutlined />}
            onClick={() => navigate(`/delivery-routes/${record.id}`)}
          >
            ìƒì„¸
          </Button>
          <Button
            type="link"
            icon={<EditOutlined />}
            onClick={() => navigate(`/delivery-routes/${record.id}/edit`)}
          />
          <Button
            type="link"
            danger
            icon={<DeleteOutlined />}
            onClick={() => handleDelete(record)}
          />
        </Space>
      ),
    },
  ];

  return (
    <div>
      <div style={{ marginBottom: 16, display: 'flex', justifyContent: 'space-between' }}>
        <Title level={2}>ë°°ì†¡ ì½”ìŠ¤ ê´€ë¦¬</Title>
        <Button
          type="primary"
          icon={<PlusOutlined />}
          onClick={() => setCreateModalOpen(true)}
        >
          ì½”ìŠ¤ ìƒì„±
        </Button>
      </div>

      <Card style={{ marginBottom: 16 }}>
        <Space wrap>
          <Input
            placeholder="ì½”ìŠ¤ëª… ë˜ëŠ” ì½”ë“œ ê²€ìƒ‰"
            prefix={<SearchOutlined />}
            style={{ width: 200 }}
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            allowClear
          />
          <Select
            placeholder="ë¶€ë¬¸ ì„ íƒ"
            style={{ width: 120 }}
            value={division}
            onChange={setDivision}
            allowClear
          >
            <Select.Option value="HQ">ë³¸ì‚¬</Select.Option>
            <Select.Option value="YEONGNAM">ì˜ë‚¨ì§€ì‚¬</Select.Option>
          </Select>
          <Select
            placeholder="ìƒíƒœ"
            style={{ width: 120 }}
            value={isActive}
            onChange={setIsActive}
          >
            <Select.Option value={true}>í™œì„±</Select.Option>
            <Select.Option value={false}>ë¹„í™œì„±</Select.Option>
          </Select>
        </Space>
      </Card>

      <Card>
        <Table
          columns={columns}
          dataSource={routes}
          rowKey="id"
          loading={isLoading}
          pagination={{
            showSizeChanger: true,
            showTotal: (total) => `ì´ ${total}ê°œ`,
          }}
        />
      </Card>

      <CreateDeliveryRouteModal
        open={createModalOpen}
        onClose={() => setCreateModalOpen(false)}
        onSuccess={() => {
          setCreateModalOpen(false);
          refetch();
        }}
      />
    </div>
  );
}
```

#### Step 3-4: ì½”ìŠ¤ ìƒì„± ëª¨ë‹¬

**íŒŒì¼**: `web/src/components/delivery-route/CreateDeliveryRouteModal.tsx` (ì‹ ê·œ ìƒì„±)

```typescript
import React from 'react';
import { Modal, Form, Input, Select, ColorPicker, message } from 'antd';
import { useMutation } from '@tanstack/react-query';
import { createDeliveryRoute } from '../../api/delivery-route.api';
import { CreateDeliveryRouteDto } from '../../types/delivery-route';

interface Props {
  open: boolean;
  onClose: () => void;
  onSuccess: () => void;
}

export default function CreateDeliveryRouteModal({ open, onClose, onSuccess }: Props) {
  const [form] = Form.useForm<CreateDeliveryRouteDto>();

  const createMutation = useMutation({
    mutationFn: createDeliveryRoute,
    onSuccess: () => {
      message.success('ë°°ì†¡ ì½”ìŠ¤ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤');
      form.resetFields();
      onSuccess();
    },
    onError: (error: any) => {
      message.error(error.response?.data?.message || 'ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
    },
  });

  const handleSubmit = async () => {
    try {
      const values = await form.validateFields();
      createMutation.mutate(values);
    } catch (error) {
      console.error('Validation failed:', error);
    }
  };

  return (
    <Modal
      title="ë°°ì†¡ ì½”ìŠ¤ ìƒì„±"
      open={open}
      onCancel={onClose}
      onOk={handleSubmit}
      confirmLoading={createMutation.isPending}
      okText="ìƒì„±"
      cancelText="ì·¨ì†Œ"
      width={600}
    >
      <Form
        form={form}
        layout="vertical"
        initialValues={{
          color: '#1890ff',
        }}
      >
        <Form.Item
          label="ì½”ìŠ¤ëª…"
          name="name"
          rules={[
            { required: true, message: 'ì½”ìŠ¤ëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”' },
            { min: 2, message: 'ìµœì†Œ 2ì ì´ìƒ ì…ë ¥í•´ì£¼ì„¸ìš”' },
          ]}
        >
          <Input placeholder="ì˜ˆ: Aì½”ìŠ¤, ë³¸ì‚¬ ì˜¤ì „ ë°°ì†¡" maxLength={50} />
        </Form.Item>

        <Form.Item
          label="ì½”ìŠ¤ ì½”ë“œ"
          name="code"
          rules={[
            { required: true, message: 'ì½”ìŠ¤ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”' },
            { pattern: /^[A-Z0-9]+$/, message: 'ì˜ë¬¸ ëŒ€ë¬¸ìì™€ ìˆ«ìë§Œ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤' },
          ]}
        >
          <Input placeholder="ì˜ˆ: A, B, C" maxLength={10} style={{ textTransform: 'uppercase' }} />
        </Form.Item>

        <Form.Item
          label="ë¶€ë¬¸"
          name="division"
          rules={[{ required: true, message: 'ë¶€ë¬¸ì„ ì„ íƒí•´ì£¼ì„¸ìš”' }]}
        >
          <Select placeholder="ë¶€ë¬¸ ì„ íƒ">
            <Select.Option value="HQ">ë³¸ì‚¬</Select.Option>
            <Select.Option value="YEONGNAM">ì˜ë‚¨ì§€ì‚¬</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item label="ì½”ìŠ¤ ìƒ‰ìƒ" name="color">
          <ColorPicker
            showText
            format="hex"
            presets={[
              {
                label: 'ì¶”ì²œ',
                colors: [
                  '#1890ff',
                  '#52c41a',
                  '#faad14',
                  '#f5222d',
                  '#722ed1',
                  '#13c2c2',
                  '#eb2f96',
                ],
              },
            ]}
          />
        </Form.Item>

        <Form.Item label="ì„¤ëª…" name="description">
          <Input.TextArea
            placeholder="ì½”ìŠ¤ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš” (ì„ íƒì‚¬í•­)"
            rows={3}
            maxLength={500}
          />
        </Form.Item>
      </Form>
    </Modal>
  );
}
```

---

## 3. Phase 2: ëª¨ë°”ì¼ ë°°ì†¡ ê¸°ëŠ¥

**ê¸°ê°„**: 10ì¼
**ëª©í‘œ**: ë°°ì†¡ê¸°ì‚¬ê°€ ëª¨ë°”ì¼ ì•±ì—ì„œ ìì‹ ì˜ ì½”ìŠ¤ë¥¼ í™•ì¸í•˜ê³  ìˆ˜ë™ìœ¼ë¡œ ì²´í¬ì¸/ì²´í¬ì•„ì›ƒ

### 3.1 ë°°ì†¡ ê¸°ë¡ API ì¶”ê°€

#### Step 4-1: Delivery Log Service ì¶”ê°€

**íŒŒì¼**: `backend/src/services/delivery-log.service.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { PrismaClient, DeliveryStatus } from '@prisma/client';
import { CreateDeliveryLogDto } from '../types/delivery-route.types';

const prisma = new PrismaClient();

export class DeliveryLogService {
  /**
   * ë°°ì†¡ ê¸°ë¡ ìƒì„± (ì²´í¬ì¸)
   */
  async createDeliveryLog(driverId: string, data: CreateDeliveryLogDto) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // ì¤‘ë³µ ì²´í¬
    const existing = await prisma.deliveryLog.findUnique({
      where: {
        routeId_siteId_deliveryDate: {
          routeId: data.routeId,
          siteId: data.siteId,
          deliveryDate: today,
        },
      },
    });

    if (existing) {
      // ì—…ë°ì´íŠ¸
      return await prisma.deliveryLog.update({
        where: { id: existing.id },
        data: {
          arrivedAt: data.arrivedAt || new Date(),
          arrivalLat: data.arrivalLat,
          arrivalLng: data.arrivalLng,
          status: data.status,
          note: data.note,
        },
      });
    }

    // ì‹ ê·œ ìƒì„±
    return await prisma.deliveryLog.create({
      data: {
        routeId: data.routeId,
        siteId: data.siteId,
        driverId,
        deliveryDate: today,
        stopNumber: data.stopNumber,
        arrivedAt: data.arrivedAt || new Date(),
        arrivalLat: data.arrivalLat,
        arrivalLng: data.arrivalLng,
        status: data.status,
        note: data.note,
      },
    });
  }

  /**
   * ë°°ì†¡ ì™„ë£Œ (ì²´í¬ì•„ì›ƒ)
   */
  async completeDelivery(logId: string, data: {
    departureLat?: number;
    departureLng?: number;
    note?: string;
  }) {
    const log = await prisma.deliveryLog.findUnique({
      where: { id: logId },
    });

    if (!log) {
      throw new Error('ë°°ì†¡ ê¸°ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }

    const departedAt = new Date();
    const actualDuration = log.arrivedAt
      ? Math.floor((departedAt.getTime() - log.arrivedAt.getTime()) / 60000)
      : null;

    return await prisma.deliveryLog.update({
      where: { id: logId },
      data: {
        departedAt,
        departureLat: data.departureLat,
        departureLng: data.departureLng,
        status: 'COMPLETED',
        actualDuration,
        note: data.note || log.note,
      },
    });
  }

  /**
   * ì˜¤ëŠ˜ì˜ ë°°ì†¡ ê¸°ë¡ ì¡°íšŒ
   */
  async getTodayDeliveryLogs(driverId: string, routeId: string) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    return await prisma.deliveryLog.findMany({
      where: {
        driverId,
        routeId,
        deliveryDate: today,
      },
      include: {
        site: {
          select: {
            id: true,
            name: true,
            address: true,
            latitude: true,
            longitude: true,
          },
        },
      },
      orderBy: { stopNumber: 'asc' },
    });
  }

  /**
   * ë°°ì†¡ ê¸°ë¡ ì´ë ¥ ì¡°íšŒ (ê´€ë¦¬ììš©)
   */
  async getDeliveryHistory(filters: {
    routeId?: string;
    driverId?: string;
    startDate?: Date;
    endDate?: Date;
    status?: DeliveryStatus;
  }) {
    const where: any = {};

    if (filters.routeId) where.routeId = filters.routeId;
    if (filters.driverId) where.driverId = filters.driverId;
    if (filters.status) where.status = filters.status;
    if (filters.startDate || filters.endDate) {
      where.deliveryDate = {};
      if (filters.startDate) where.deliveryDate.gte = filters.startDate;
      if (filters.endDate) where.deliveryDate.lte = filters.endDate;
    }

    return await prisma.deliveryLog.findMany({
      where,
      include: {
        site: {
          select: { id: true, name: true, address: true },
        },
        driver: {
          select: { id: true, name: true, phone: true },
        },
        route: {
          select: { id: true, name: true, code: true },
        },
      },
      orderBy: [{ deliveryDate: 'desc' }, { stopNumber: 'asc' }],
    });
  }
}
```

#### Step 4-2: Delivery Log Controller & Routes

**íŒŒì¼**: `backend/src/controllers/delivery-log.controller.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { Request, Response, NextFunction } from 'express';
import { DeliveryLogService } from '../services/delivery-log.service';

const deliveryLogService = new DeliveryLogService();

/**
 * POST /api/v1/delivery-logs/check-in
 * ì²´í¬ì¸ (ë„ì°©)
 */
export async function checkIn(req: Request, res: Response, next: NextFunction) {
  try {
    const driverId = req.user?.id;
    if (!driverId) {
      return res.status(401).json({ success: false, message: 'ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤' });
    }

    const log = await deliveryLogService.createDeliveryLog(driverId, req.body);

    res.status(201).json({
      success: true,
      data: log,
      message: 'ì²´í¬ì¸ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-logs/:id/check-out
 * ì²´í¬ì•„ì›ƒ (ì¶œë°œ)
 */
export async function checkOut(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const log = await deliveryLogService.completeDelivery(id, req.body);

    res.json({
      success: true,
      data: log,
      message: 'ë°°ì†¡ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-logs/today
 * ì˜¤ëŠ˜ì˜ ë°°ì†¡ ê¸°ë¡ ì¡°íšŒ
 */
export async function getTodayLogs(req: Request, res: Response, next: NextFunction) {
  try {
    const driverId = req.user?.id;
    const { routeId } = req.query;

    if (!driverId || !routeId) {
      return res.status(400).json({ success: false, message: 'í•„ìˆ˜ íŒŒë¼ë¯¸í„°ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤' });
    }

    const logs = await deliveryLogService.getTodayDeliveryLogs(driverId, routeId as string);

    res.json({
      success: true,
      data: logs,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * GET /api/v1/delivery-logs/history
 * ë°°ì†¡ ê¸°ë¡ ì´ë ¥ ì¡°íšŒ (ê´€ë¦¬ì)
 */
export async function getHistory(req: Request, res: Response, next: NextFunction) {
  try {
    const { routeId, driverId, startDate, endDate, status } = req.query;

    const logs = await deliveryLogService.getDeliveryHistory({
      routeId: routeId as string | undefined,
      driverId: driverId as string | undefined,
      startDate: startDate ? new Date(startDate as string) : undefined,
      endDate: endDate ? new Date(endDate as string) : undefined,
      status: status as any,
    });

    res.json({
      success: true,
      data: logs,
    });
  } catch (error) {
    next(error);
  }
}
```

**íŒŒì¼**: `backend/src/routes/delivery-log.routes.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { Router } from 'express';
import * as deliveryLogController from '../controllers/delivery-log.controller';
import { authenticate } from '../middleware/auth.middleware';
import { authorize } from '../middleware/role.middleware';
import { validate } from '../middleware/validation.middleware';
import { createDeliveryLogSchema } from '../validators/delivery-route.validator';

const router = Router();

router.use(authenticate);

// ë°°ì†¡ê¸°ì‚¬ìš©
router.post(
  '/check-in',
  authorize(['DELIVERY_DRIVER']),
  validate({ body: createDeliveryLogSchema }),
  deliveryLogController.checkIn
);

router.post(
  '/:id/check-out',
  authorize(['DELIVERY_DRIVER']),
  deliveryLogController.checkOut
);

router.get(
  '/today',
  authorize(['DELIVERY_DRIVER']),
  deliveryLogController.getTodayLogs
);

// ê´€ë¦¬ììš©
router.get(
  '/history',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  deliveryLogController.getHistory
);

export default router;
```

**íŒŒì¼**: `backend/src/routes/index.ts` (ìˆ˜ì • - ë¼ìš°íŠ¸ ì¶”ê°€)

```typescript
import deliveryLogRoutes from './delivery-log.routes';

// ...
app.use('/api/v1/delivery-logs', deliveryLogRoutes);
```

---

### 3.2 ëª¨ë°”ì¼ ì•± êµ¬í˜„

#### Step 5-1: Types & API Client

**íŒŒì¼**: `mobile/src/types/delivery-route.ts` (ì‹ ê·œ ìƒì„±)

```typescript
export interface DeliveryRoute {
  id: string;
  name: string;
  code: string;
  color: string;
  stopsCount: number;
  stops: DeliveryRouteStop[];
}

export interface DeliveryRouteStop {
  id: string;
  stopNumber: number;
  estimatedArrival?: string;
  estimatedDuration?: number;
  notes?: string;
  site: {
    id: string;
    name: string;
    address: string;
    latitude: number;
    longitude: number;
  };
}

export interface DeliveryLog {
  id: string;
  routeId: string;
  siteId: string;
  stopNumber: number;
  arrivedAt?: string;
  departedAt?: string;
  status: 'PENDING' | 'IN_TRANSIT' | 'ARRIVED' | 'COMPLETED' | 'DELAYED' | 'ISSUE';
  site: {
    id: string;
    name: string;
    address: string;
  };
}
```

**íŒŒì¼**: `mobile/src/api/delivery-route.api.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import api from './client';
import { DeliveryRoute, DeliveryLog } from '../types/delivery-route';

/**
 * ë‚´ ë°°ì†¡ ì½”ìŠ¤ ì¡°íšŒ
 */
export async function getMyRoutes(): Promise<DeliveryRoute[]> {
  const response = await api.get('/delivery-routes/my-routes');
  return response.data.data;
}

/**
 * ì˜¤ëŠ˜ì˜ ë°°ì†¡ ê¸°ë¡ ì¡°íšŒ
 */
export async function getTodayDeliveryLogs(routeId: string): Promise<DeliveryLog[]> {
  const response = await api.get('/delivery-logs/today', {
    params: { routeId },
  });
  return response.data.data;
}

/**
 * ì²´í¬ì¸
 */
export async function checkIn(data: {
  routeId: string;
  siteId: string;
  stopNumber: number;
  arrivalLat?: number;
  arrivalLng?: number;
  status: string;
  note?: string;
}): Promise<DeliveryLog> {
  const response = await api.post('/delivery-logs/check-in', data);
  return response.data.data;
}

/**
 * ì²´í¬ì•„ì›ƒ
 */
export async function checkOut(logId: string, data: {
  departureLat?: number;
  departureLng?: number;
  note?: string;
}): Promise<DeliveryLog> {
  const response = await api.post(`/delivery-logs/${logId}/check-out`, data);
  return response.data.data;
}
```

#### Step 5-2: ë°°ì†¡ ì½”ìŠ¤ í™”ë©´

**íŒŒì¼**: `mobile/src/screens/DeliveryRouteScreen.tsx` (ì‹ ê·œ ìƒì„±)

```typescript
import React, { useState } from 'react';
import { View, Text, ScrollView, TouchableOpacity, StyleSheet, Alert } from 'react-native';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as Location from 'expo-location';
import { getMyRoutes, getTodayDeliveryLogs, checkIn, checkOut } from '../api/delivery-route.api';
import { DeliveryRoute, DeliveryLog } from '../types/delivery-route';

export default function DeliveryRouteScreen() {
  const queryClient = useQueryClient();
  const [selectedRoute, setSelectedRoute] = useState<DeliveryRoute | null>(null);

  // ë‚´ ì½”ìŠ¤ ëª©ë¡ ì¡°íšŒ
  const { data: routes, isLoading: routesLoading } = useQuery({
    queryKey: ['my-routes'],
    queryFn: getMyRoutes,
  });

  // ì˜¤ëŠ˜ì˜ ë°°ì†¡ ê¸°ë¡
  const { data: logs, refetch: refetchLogs } = useQuery({
    queryKey: ['today-logs', selectedRoute?.id],
    queryFn: () => getTodayDeliveryLogs(selectedRoute!.id),
    enabled: !!selectedRoute,
  });

  // ì²´í¬ì¸ Mutation
  const checkInMutation = useMutation({
    mutationFn: async (stop: any) => {
      // GPS ì¢Œí‘œ ê°€ì ¸ì˜¤ê¸°
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        throw new Error('ìœ„ì¹˜ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤');
      }

      const location = await Location.getCurrentPositionAsync({});

      return checkIn({
        routeId: selectedRoute!.id,
        siteId: stop.site.id,
        stopNumber: stop.stopNumber,
        arrivalLat: location.coords.latitude,
        arrivalLng: location.coords.longitude,
        status: 'ARRIVED',
      });
    },
    onSuccess: () => {
      Alert.alert('ì„±ê³µ', 'ì²´í¬ì¸ë˜ì—ˆìŠµë‹ˆë‹¤');
      refetchLogs();
    },
    onError: (error: any) => {
      Alert.alert('ì˜¤ë¥˜', error.message || 'ì²´í¬ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
    },
  });

  // ì²´í¬ì•„ì›ƒ Mutation
  const checkOutMutation = useMutation({
    mutationFn: async (logId: string) => {
      const location = await Location.getCurrentPositionAsync({});

      return checkOut(logId, {
        departureLat: location.coords.latitude,
        departureLng: location.coords.longitude,
      });
    },
    onSuccess: () => {
      Alert.alert('ì„±ê³µ', 'ë°°ì†¡ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
      refetchLogs();
    },
    onError: (error: any) => {
      Alert.alert('ì˜¤ë¥˜', error.message || 'ì²´í¬ì•„ì›ƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
    },
  });

  // ë¡œê·¸ì¸ ë¡œë“œ ì¤‘
  if (routesLoading) {
    return (
      <View style={styles.container}>
        <Text>ë¡œë”© ì¤‘...</Text>
      </View>
    );
  }

  // ì½”ìŠ¤ ì„ íƒ í™”ë©´
  if (!selectedRoute) {
    return (
      <View style={styles.container}>
        <Text style={styles.title}>ë‚´ ë°°ì†¡ ì½”ìŠ¤</Text>
        {routes?.map((route) => (
          <TouchableOpacity
            key={route.id}
            style={[styles.routeCard, { borderLeftColor: route.color }]}
            onPress={() => setSelectedRoute(route)}
          >
            <View style={styles.routeHeader}>
              <Text style={styles.routeCode}>{route.code}</Text>
              <Text style={styles.routeName}>{route.name}</Text>
            </View>
            <Text style={styles.stopsCount}>ì‚¬ì—…ì¥ {route.stopsCount}ê°œ</Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  }

  // ë°°ì†¡ ì§„í–‰ í™”ë©´
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => setSelectedRoute(null)}>
          <Text style={styles.backButton}>â† ë’¤ë¡œ</Text>
        </TouchableOpacity>
        <Text style={styles.title}>{selectedRoute.name}</Text>
      </View>

      <ScrollView>
        {selectedRoute.stops.map((stop, index) => {
          const log = logs?.find((l) => l.siteId === stop.site.id);
          const isCompleted = log?.status === 'COMPLETED';
          const isArrived = log?.status === 'ARRIVED';

          return (
            <View key={stop.id} style={styles.stopCard}>
              <View style={styles.stopHeader}>
                <View style={styles.stopNumberBadge}>
                  <Text style={styles.stopNumberText}>{stop.stopNumber}</Text>
                </View>
                <View style={styles.stopInfo}>
                  <Text style={styles.siteName}>{stop.site.name}</Text>
                  <Text style={styles.siteAddress}>{stop.site.address}</Text>
                  {stop.estimatedArrival && (
                    <Text style={styles.estimatedTime}>
                      ì˜ˆìƒ ë„ì°©: {stop.estimatedArrival}
                    </Text>
                  )}
                </View>
              </View>

              {isCompleted ? (
                <View style={styles.completedBadge}>
                  <Text style={styles.completedText}>âœ“ ì™„ë£Œ</Text>
                  {log.arrivedAt && (
                    <Text style={styles.timeText}>
                      ë„ì°©: {new Date(log.arrivedAt).toLocaleTimeString('ko-KR', {
                        hour: '2-digit',
                        minute: '2-digit',
                      })}
                    </Text>
                  )}
                </View>
              ) : isArrived ? (
                <TouchableOpacity
                  style={styles.checkoutButton}
                  onPress={() => checkOutMutation.mutate(log.id)}
                  disabled={checkOutMutation.isPending}
                >
                  <Text style={styles.buttonText}>
                    {checkOutMutation.isPending ? 'ì²˜ë¦¬ ì¤‘...' : 'ì²´í¬ì•„ì›ƒ'}
                  </Text>
                </TouchableOpacity>
              ) : (
                <TouchableOpacity
                  style={styles.checkinButton}
                  onPress={() => checkInMutation.mutate(stop)}
                  disabled={checkInMutation.isPending}
                >
                  <Text style={styles.buttonText}>
                    {checkInMutation.isPending ? 'ì²˜ë¦¬ ì¤‘...' : 'ì²´í¬ì¸'}
                  </Text>
                </TouchableOpacity>
              )}

              {stop.notes && (
                <Text style={styles.notes}>ë©”ëª¨: {stop.notes}</Text>
              )}
            </View>
          );
        })}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  backButton: {
    fontSize: 16,
    color: '#1890ff',
    marginRight: 12,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  routeCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    borderLeftWidth: 4,
    elevation: 2,
  },
  routeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  routeCode: {
    fontSize: 18,
    fontWeight: 'bold',
    marginRight: 8,
  },
  routeName: {
    fontSize: 18,
  },
  stopsCount: {
    fontSize: 14,
    color: '#666',
  },
  stopCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 2,
  },
  stopHeader: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  stopNumberBadge: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#1890ff',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  stopNumberText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
  },
  stopInfo: {
    flex: 1,
  },
  siteName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  siteAddress: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  estimatedTime: {
    fontSize: 12,
    color: '#1890ff',
  },
  checkinButton: {
    backgroundColor: '#52c41a',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  checkoutButton: {
    backgroundColor: '#faad14',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  completedBadge: {
    backgroundColor: '#f0f0f0',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  completedText: {
    color: '#52c41a',
    fontWeight: 'bold',
    fontSize: 16,
  },
  timeText: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  buttonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
  },
  notes: {
    fontSize: 12,
    color: '#666',
    marginTop: 8,
    fontStyle: 'italic',
  },
});
```

---

## 4. Phase 3: GPS ìë™ ì¶”ì 

**ê¸°ê°„**: 5ì¼
**ëª©í‘œ**: ë°±ê·¸ë¼ìš´ë“œ ìœ„ì¹˜ ì¶”ì  ë° Geofencingì„ í†µí•œ ìë™ ì²´í¬ì¸ ì œì•ˆ

### 4.1 ë°±ê·¸ë¼ìš´ë“œ ìœ„ì¹˜ ì¶”ì  êµ¬í˜„

**íŒŒì¼**: `mobile/src/services/location-tracking.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import * as Location from 'expo-location';
import * as TaskManager from 'expo-task-manager';
import AsyncStorage from '@react-native-async-storage/async-storage';

const LOCATION_TASK_NAME = 'background-location-task';
const GEOFENCE_TASK_NAME = 'delivery-geofence-task';

/**
 * ë°±ê·¸ë¼ìš´ë“œ ìœ„ì¹˜ ì¶”ì  íƒœìŠ¤í¬ ì •ì˜
 */
TaskManager.defineTask(LOCATION_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error('Location task error:', error);
    return;
  }

  if (data) {
    const { locations } = data as any;
    const location = locations[0];

    // ìœ„ì¹˜ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê±°ë‚˜ ì„œë²„ë¡œ ì „ì†¡
    try {
      await sendLocationToServer({
        latitude: location.coords.latitude,
        longitude: location.coords.longitude,
        timestamp: new Date(location.timestamp),
      });
    } catch (err) {
      console.error('Failed to send location:', err);
    }
  }
});

/**
 * Geofencing íƒœìŠ¤í¬ ì •ì˜
 */
TaskManager.defineTask(GEOFENCE_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error('Geofence task error:', error);
    return;
  }

  if (data) {
    const { eventType, region } = data as any;

    if (eventType === Location.GeofencingEventType.Enter) {
      // ì‚¬ì—…ì¥ ë°˜ê²½ ì§„ì… â†’ ì²´í¬ì¸ ì•Œë¦¼
      await showCheckInNotification(region.identifier);
    }
  }
});

/**
 * ë°±ê·¸ë¼ìš´ë“œ ìœ„ì¹˜ ì¶”ì  ì‹œì‘
 */
export async function startLocationTracking() {
  // ê¶Œí•œ í™•ì¸
  const { status: foregroundStatus } = await Location.requestForegroundPermissionsAsync();
  if (foregroundStatus !== 'granted') {
    throw new Error('ìœ„ì¹˜ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤');
  }

  const { status: backgroundStatus } = await Location.requestBackgroundPermissionsAsync();
  if (backgroundStatus !== 'granted') {
    throw new Error('ë°±ê·¸ë¼ìš´ë“œ ìœ„ì¹˜ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤');
  }

  // ìœ„ì¹˜ ì¶”ì  ì‹œì‘
  await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
    accuracy: Location.Accuracy.High,
    timeInterval: 30000, // 30ì´ˆë§ˆë‹¤
    distanceInterval: 100, // 100m ì´ë™ ì‹œ
    foregroundService: {
      notificationTitle: 'ë°°ì†¡ ì¤‘',
      notificationBody: 'ìœ„ì¹˜ê°€ ì¶”ì ë˜ê³  ìˆìŠµë‹ˆë‹¤',
      notificationColor: '#1890ff',
    },
    pausesUpdatesAutomatically: false,
    showsBackgroundLocationIndicator: true,
  });

  await AsyncStorage.setItem('location_tracking', 'true');
}

/**
 * ë°±ê·¸ë¼ìš´ë“œ ìœ„ì¹˜ ì¶”ì  ì¤‘ì§€
 */
export async function stopLocationTracking() {
  await Location.stopLocationUpdatesAsync(LOCATION_TASK_NAME);
  await AsyncStorage.setItem('location_tracking', 'false');
}

/**
 * Geofencing ì„¤ì •
 */
export async function setupGeofencing(stops: Array<{
  id: string;
  latitude: number;
  longitude: number;
}>) {
  const regions = stops.map((stop) => ({
    identifier: stop.id,
    latitude: stop.latitude,
    longitude: stop.longitude,
    radius: 100, // 100m ë°˜ê²½
    notifyOnEnter: true,
    notifyOnExit: false,
  }));

  await Location.startGeofencingAsync(GEOFENCE_TASK_NAME, regions);
}

/**
 * Geofencing í•´ì œ
 */
export async function stopGeofencing() {
  await Location.stopGeofencingAsync(GEOFENCE_TASK_NAME);
}

/**
 * ìœ„ì¹˜ ë°ì´í„° ì„œë²„ ì „ì†¡
 */
async function sendLocationToServer(location: {
  latitude: number;
  longitude: number;
  timestamp: Date;
}) {
  // API í˜¸ì¶œ (ì‹¤ì œ êµ¬í˜„ í•„ìš”)
  console.log('Sending location:', location);
}

/**
 * ì²´í¬ì¸ ì•Œë¦¼ í‘œì‹œ
 */
async function showCheckInNotification(siteId: string) {
  // ë¡œì»¬ ì•Œë¦¼ í‘œì‹œ (ì‹¤ì œ êµ¬í˜„ í•„ìš”)
  console.log('Show check-in notification for site:', siteId);
}
```

**íŒŒì¼**: `mobile/src/screens/DeliveryControlScreen.tsx` (ì‹ ê·œ ìƒì„±)

```typescript
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Switch } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { startLocationTracking, stopLocationTracking } from '../services/location-tracking';

export default function DeliveryControlScreen() {
  const [isTracking, setIsTracking] = useState(false);

  useEffect(() => {
    checkTrackingStatus();
  }, []);

  const checkTrackingStatus = async () => {
    const status = await AsyncStorage.getItem('location_tracking');
    setIsTracking(status === 'true');
  };

  const handleToggleTracking = async () => {
    try {
      if (isTracking) {
        await stopLocationTracking();
        setIsTracking(false);
      } else {
        await startLocationTracking();
        setIsTracking(true);
      }
    } catch (error: any) {
      alert(error.message);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ë°°ì†¡ ì„¤ì •</Text>

      <View style={styles.card}>
        <View style={styles.row}>
          <View style={styles.textContainer}>
            <Text style={styles.label}>ë°°ì†¡ ì¶”ì </Text>
            <Text style={styles.description}>
              ë°°ì†¡ ì¤‘ ìœ„ì¹˜ë¥¼ ìë™ìœ¼ë¡œ ê¸°ë¡í•©ë‹ˆë‹¤
            </Text>
          </View>
          <Switch
            value={isTracking}
            onValueChange={handleToggleTracking}
            trackColor={{ false: '#767577', true: '#52c41a' }}
            thumbColor={isTracking ? '#fff' : '#f4f3f4'}
          />
        </View>

        {isTracking && (
          <View style={styles.statusContainer}>
            <View style={styles.statusIndicator} />
            <Text style={styles.statusText}>ì¶”ì  ì¤‘</Text>
          </View>
        )}
      </View>

      <View style={styles.infoCard}>
        <Text style={styles.infoTitle}>ë°°ì†¡ ì¶”ì  ì•ˆë‚´</Text>
        <Text style={styles.infoText}>
          â€¢ 30ì´ˆë§ˆë‹¤ ë˜ëŠ” 100m ì´ë™ ì‹œ ìœ„ì¹˜ê°€ ê¸°ë¡ë©ë‹ˆë‹¤{'\n'}
          â€¢ ë°°ì†¡ ì‹œì‘ ì‹œ ì¶”ì ì„ ì¼œê³ , ì¢…ë£Œ ì‹œ êº¼ì£¼ì„¸ìš”{'\n'}
          â€¢ ë°°í„°ë¦¬ ì ˆì•½ì„ ìœ„í•´ ë°°ì†¡ì´ ì•„ë‹ ë•ŒëŠ” êº¼ë‘ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤{'\n'}
          â€¢ ì‚¬ì—…ì¥ ê·¼ì²˜ ë„ì°© ì‹œ ìë™ìœ¼ë¡œ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤
        </Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  card: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  textContainer: {
    flex: 1,
  },
  label: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  description: {
    fontSize: 14,
    color: '#666',
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  statusIndicator: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: '#52c41a',
    marginRight: 8,
  },
  statusText: {
    fontSize: 14,
    color: '#52c41a',
    fontWeight: 'bold',
  },
  infoCard: {
    backgroundColor: '#e6f7ff',
    borderRadius: 8,
    padding: 16,
    borderLeftWidth: 4,
    borderLeftColor: '#1890ff',
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#1890ff',
  },
  infoText: {
    fontSize: 14,
    color: '#666',
    lineHeight: 20,
  },
});
```

---

## 5. Phase 4: ê²½ë¡œ ìµœì í™”

**ê¸°ê°„**: 5ì¼
**ëª©í‘œ**: Kakao Mobility APIë¥¼ í™œìš©í•œ ê²½ë¡œ ì‹œë®¬ë ˆì´ì…˜ ë° ìµœì í™”

### 5.1 ê²½ë¡œ ìµœì í™” Service

**íŒŒì¼**: `backend/src/services/route-optimization.service.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import axios from 'axios';
import { DeliveryRouteStop } from '@prisma/client';

interface RouteSegment {
  from: string;
  to: string;
  distance: number;
  duration: number;
  estimatedArrival: string;
}

export class RouteOptimizationService {
  private kakaoRestApiKey = process.env.KAKAO_REST_API_KEY!;

  /**
   * ë‘ ì§€ì  ê°„ ì´ë™ ì‹œê°„ ë° ê±°ë¦¬ ê³„ì‚°
   */
  async calculateRoute(
    origin: { lat: number; lng: number },
    destination: { lat: number; lng: number }
  ): Promise<{
    distanceMeters: number;
    durationSeconds: number;
    distanceKm: number;
    durationMinutes: number;
  }> {
    const url = 'https://apis-navi.kakaomobility.com/v1/directions';

    try {
      const response = await axios.get(url, {
        params: {
          origin: `${origin.lng},${origin.lat}`,
          destination: `${destination.lng},${destination.lat}`,
          priority: 'RECOMMEND',
        },
        headers: {
          Authorization: `KakaoAK ${this.kakaoRestApiKey}`,
        },
      });

      const route = response.data.routes[0];

      return {
        distanceMeters: route.summary.distance,
        durationSeconds: route.summary.duration,
        distanceKm: route.summary.distance / 1000,
        durationMinutes: Math.ceil(route.summary.duration / 60),
      };
    } catch (error) {
      console.error('Kakao Mobility API error:', error);
      throw new Error('ê²½ë¡œ ê³„ì‚°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
    }
  }

  /**
   * ì „ì²´ ì½”ìŠ¤ ì‹œë®¬ë ˆì´ì…˜
   */
  async simulateRoute(stops: Array<{
    stopNumber: number;
    site: {
      name: string;
      latitude: number;
      longitude: number;
    };
  }>, startTime: Date = new Date()) {
    const segments: RouteSegment[] = [];
    let totalDistance = 0;
    let totalDuration = 0;
    let currentTime = new Date(startTime);

    for (let i = 0; i < stops.length - 1; i++) {
      const origin = {
        lat: stops[i].site.latitude,
        lng: stops[i].site.longitude,
      };
      const destination = {
        lat: stops[i + 1].site.latitude,
        lng: stops[i + 1].site.longitude,
      };

      const route = await this.calculateRoute(origin, destination);

      totalDistance += route.distanceKm;
      totalDuration += route.durationMinutes;

      // ì •ë¥˜ì¥ ì²´ë¥˜ ì‹œê°„ (15ë¶„) ì¶”ê°€
      const stopDuration = 15;
      currentTime = new Date(currentTime.getTime() + (route.durationMinutes + stopDuration) * 60000);

      segments.push({
        from: stops[i].site.name,
        to: stops[i + 1].site.name,
        distance: route.distanceKm,
        duration: route.durationMinutes,
        estimatedArrival: currentTime.toISOString(),
      });
    }

    return {
      totalDistance: Math.round(totalDistance * 10) / 10,
      totalDuration: totalDuration + (stops.length * 15), // ê° ì •ë¥˜ì¥ 15ë¶„
      segments,
    };
  }

  /**
   * ê²½ë¡œ ìµœì í™” (ê°„ë‹¨í•œ Nearest Neighbor ì•Œê³ ë¦¬ì¦˜)
   */
  async optimizeRoute(
    sites: Array<{ id: string; name: string; latitude: number; longitude: number }>,
    startPoint: { lat: number; lng: number }
  ) {
    const unvisited = [...sites];
    const optimized: typeof sites = [];
    let current = startPoint;

    while (unvisited.length > 0) {
      let nearest = null;
      let minDistance = Infinity;

      for (const site of unvisited) {
        const route = await this.calculateRoute(current, {
          lat: site.latitude,
          lng: site.longitude,
        });

        if (route.distanceKm < minDistance) {
          minDistance = route.distanceKm;
          nearest = site;
        }
      }

      if (nearest) {
        optimized.push(nearest);
        current = { lat: nearest.latitude, lng: nearest.longitude };
        unvisited.splice(unvisited.indexOf(nearest), 1);
      }
    }

    return optimized;
  }
}
```

### 5.2 ê²½ë¡œ ì‹œë®¬ë ˆì´ì…˜ Controller & Routes

**íŒŒì¼**: `backend/src/controllers/route-optimization.controller.ts` (ì‹ ê·œ ìƒì„±)

```typescript
import { Request, Response, NextFunction } from 'express';
import { RouteOptimizationService } from '../services/route-optimization.service';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const routeOptimizationService = new RouteOptimizationService();

/**
 * POST /api/v1/delivery-routes/:id/simulate
 * ê²½ë¡œ ì‹œë®¬ë ˆì´ì…˜
 */
export async function simulateRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const { startTime } = req.body;

    // ì½”ìŠ¤ ì •ë³´ ì¡°íšŒ
    const route = await prisma.deliveryRoute.findUnique({
      where: { id },
      include: {
        routeStops: {
          where: { isActive: true },
          include: {
            site: {
              select: {
                name: true,
                latitude: true,
                longitude: true,
              },
            },
          },
          orderBy: { stopNumber: 'asc' },
        },
      },
    });

    if (!route) {
      return res.status(404).json({
        success: false,
        message: 'ì½”ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
      });
    }

    // ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
    const simulation = await routeOptimizationService.simulateRoute(
      route.routeStops,
      startTime ? new Date(startTime) : new Date('2025-01-01 08:00')
    );

    res.json({
      success: true,
      data: simulation,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * POST /api/v1/delivery-routes/:id/optimize
 * ê²½ë¡œ ìµœì í™”
 */
export async function optimizeRoute(req: Request, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const { startLat, startLng } = req.body;

    // ì½”ìŠ¤ ì •ë³´ ì¡°íšŒ
    const route = await prisma.deliveryRoute.findUnique({
      where: { id },
      include: {
        routeStops: {
          where: { isActive: true },
          include: {
            site: {
              select: {
                id: true,
                name: true,
                latitude: true,
                longitude: true,
              },
            },
          },
        },
      },
    });

    if (!route) {
      return res.status(404).json({
        success: false,
        message: 'ì½”ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
      });
    }

    // ìµœì í™” ì‹¤í–‰
    const sites = route.routeStops.map((stop) => stop.site);
    const optimized = await routeOptimizationService.optimizeRoute(sites, {
      lat: startLat,
      lng: startLng,
    });

    res.json({
      success: true,
      data: optimized,
      message: 'ìµœì  ê²½ë¡œê°€ ê³„ì‚°ë˜ì—ˆìŠµë‹ˆë‹¤',
    });
  } catch (error) {
    next(error);
  }
}
```

**íŒŒì¼**: `backend/src/routes/delivery-route.routes.ts` (ìˆ˜ì • - ë¼ìš°íŠ¸ ì¶”ê°€)

```typescript
import * as routeOptimizationController from '../controllers/route-optimization.controller';

// ... ê¸°ì¡´ ë¼ìš°íŠ¸

/**
 * POST /api/v1/delivery-routes/:id/simulate
 * ê²½ë¡œ ì‹œë®¬ë ˆì´ì…˜
 */
router.post(
  '/:id/simulate',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  routeOptimizationController.simulateRoute
);

/**
 * POST /api/v1/delivery-routes/:id/optimize
 * ê²½ë¡œ ìµœì í™”
 */
router.post(
  '/:id/optimize',
  authorize(['MANAGER', 'ADMIN', 'SUPER_ADMIN']),
  routeOptimizationController.optimizeRoute
);
```

### 5.3 ì›¹ ê´€ë¦¬ì - ì‹œë®¬ë ˆì´ì…˜ í˜ì´ì§€

**íŒŒì¼**: `web/src/pages/delivery-route/RouteSimulationPage.tsx` (ì‹ ê·œ ìƒì„±)

```typescript
import React, { useState } from 'react';
import { useParams } from 'react-router-dom';
import { useQuery, useMutation } from '@tanstack/react-query';
import { Card, Button, Statistic, Timeline, Space, message, Spin } from 'antd';
import { PlayCircleOutlined, ThunderboltOutlined } from '@ant-design/icons';
import { getDeliveryRouteById } from '../../api/delivery-route.api';
import axios from '../../lib/axios';

export default function RouteSimulationPage() {
  const { id } = useParams<{ id: string }>();
  const [simulation, setSimulation] = useState<any>(null);

  // ì½”ìŠ¤ ì •ë³´ ì¡°íšŒ
  const { data: route, isLoading } = useQuery({
    queryKey: ['delivery-route', id],
    queryFn: () => getDeliveryRouteById(id!),
  });

  // ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
  const simulateMutation = useMutation({
    mutationFn: async () => {
      const response = await axios.post(`/delivery-routes/${id}/simulate`, {
        startTime: new Date('2025-01-01 08:00').toISOString(),
      });
      return response.data.data;
    },
    onSuccess: (data) => {
      setSimulation(data);
      message.success('ì‹œë®¬ë ˆì´ì…˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
    },
    onError: () => {
      message.error('ì‹œë®¬ë ˆì´ì…˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
    },
  });

  if (isLoading) {
    return (
      <div style={{ textAlign: 'center', padding: 50 }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <div style={{ padding: 24 }}>
      <Card>
        <h2>{route?.name} - ê²½ë¡œ ì‹œë®¬ë ˆì´ì…˜</h2>
        <p>ì´ ì‚¬ì—…ì¥: {route?.stopsCount}ê°œ</p>

        <Button
          type="primary"
          icon={<PlayCircleOutlined />}
          onClick={() => simulateMutation.mutate()}
          loading={simulateMutation.isPending}
          size="large"
        >
          ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
        </Button>
      </Card>

      {simulation && (
        <>
          <Card style={{ marginTop: 16 }}>
            <Space size="large">
              <Statistic
                title="ì´ ê±°ë¦¬"
                value={simulation.totalDistance}
                suffix="km"
              />
              <Statistic
                title="ì´ ì†Œìš” ì‹œê°„"
                value={simulation.totalDuration}
                suffix="ë¶„"
              />
              <Statistic
                title="í‰ê·  ì†ë„"
                value={Math.round((simulation.totalDistance / simulation.totalDuration) * 60)}
                suffix="km/h"
              />
            </Space>
          </Card>

          <Card title="ê²½ë¡œ ìƒì„¸" style={{ marginTop: 16 }}>
            <Timeline>
              {simulation.segments.map((segment: any, i: number) => (
                <Timeline.Item key={i}>
                  <strong>{segment.to}</strong>
                  <br />
                  <span style={{ color: '#666' }}>
                    ë„ì°© ì˜ˆì •: {new Date(segment.estimatedArrival).toLocaleTimeString('ko-KR', {
                      hour: '2-digit',
                      minute: '2-digit',
                    })}
                  </span>
                  <br />
                  <span style={{ color: '#999', fontSize: 12 }}>
                    ì†Œìš”: {segment.duration}ë¶„ ({segment.distance.toFixed(1)}km)
                  </span>
                </Timeline.Item>
              ))}
            </Timeline>
          </Card>
        </>
      )}
    </div>
  );
}
```

---

## 6. í…ŒìŠ¤íŠ¸ ê³„íš

### 6.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

**ë°±ì—”ë“œ Service í…ŒìŠ¤íŠ¸**

```bash
# Jest ì„¤ì¹˜
npm install --save-dev jest @types/jest ts-jest

# í…ŒìŠ¤íŠ¸ íŒŒì¼: backend/src/services/__tests__/delivery-route.service.test.ts
```

```typescript
import { DeliveryRouteService } from '../delivery-route.service';

describe('DeliveryRouteService', () => {
  let service: DeliveryRouteService;

  beforeEach(() => {
    service = new DeliveryRouteService();
  });

  describe('createDeliveryRoute', () => {
    it('should create a new delivery route', async () => {
      const dto = {
        name: 'Aì½”ìŠ¤',
        code: 'A',
        division: 'HQ',
        description: 'ë³¸ì‚¬ ì˜¤ì „ ë°°ì†¡',
      };

      const result = await service.createDeliveryRoute(dto as any);

      expect(result).toHaveProperty('id');
      expect(result.name).toBe('Aì½”ìŠ¤');
    });

    it('should throw error for duplicate code', async () => {
      // ì¤‘ë³µ í…ŒìŠ¤íŠ¸
    });
  });
});
```

### 6.2 í†µí•© í…ŒìŠ¤íŠ¸

**API ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸**

```bash
# Supertest ì„¤ì¹˜
npm install --save-dev supertest @types/supertest
```

```typescript
import request from 'supertest';
import app from '../app';

describe('Delivery Route API', () => {
  let authToken: string;

  beforeAll(async () => {
    // ë¡œê·¸ì¸í•˜ì—¬ í† í° ë°›ê¸°
    const response = await request(app)
      .post('/api/v1/auth/login')
      .send({ phone: '01012345678', password: '1234' });

    authToken = response.body.data.token;
  });

  describe('POST /api/v1/delivery-routes', () => {
    it('should create a new route with valid data', async () => {
      const response = await request(app)
        .post('/api/v1/delivery-routes')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: 'Test Route',
          code: 'TEST',
          division: 'HQ',
        });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
    });

    it('should return 422 for invalid data', async () => {
      const response = await request(app)
        .post('/api/v1/delivery-routes')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: 'A', // Too short
        });

      expect(response.status).toBe(422);
    });
  });
});
```

### 6.3 ëª¨ë°”ì¼ í…ŒìŠ¤íŠ¸

**React Native Testing Library**

```bash
cd mobile
npm install --save-dev @testing-library/react-native
```

```typescript
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import DeliveryRouteScreen from '../DeliveryRouteScreen';

describe('DeliveryRouteScreen', () => {
  it('should display routes', async () => {
    const { getByText } = render(<DeliveryRouteScreen />);

    await waitFor(() => {
      expect(getByText('Aì½”ìŠ¤')).toBeTruthy();
    });
  });

  it('should handle check-in', async () => {
    const { getByText } = render(<DeliveryRouteScreen />);

    const checkinButton = getByText('ì²´í¬ì¸');
    fireEvent.press(checkinButton);

    await waitFor(() => {
      expect(getByText('ì²´í¬ì¸ë˜ì—ˆìŠµë‹ˆë‹¤')).toBeTruthy();
    });
  });
});
```

---

## 7. ë°°í¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

### 7.1 Phase 1 ë°°í¬ ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ë°ì´í„°ë² ì´ìŠ¤**
- [ ] í”„ë¡œë•ì…˜ DB ë°±ì—… ì™„ë£Œ
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸ ì™„ë£Œ (ë¡œì»¬)
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡¤ë°± ê³„íš ìˆ˜ë¦½

**ë°±ì—”ë“œ**
- [ ] ëª¨ë“  API ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸ ì™„ë£Œ
- [ ] Validator ê²€ì¦ ì™„ë£Œ
- [ ] ì—ëŸ¬ í•¸ë“¤ë§ í™•ì¸
- [ ] ê¶Œí•œ ì²´í¬ í™•ì¸ (ì—­í• ë³„ ì ‘ê·¼ ì œì–´)

**í”„ë¡ íŠ¸ì—”ë“œ**
- [ ] ì½”ìŠ¤ ìƒì„± ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] ì½”ìŠ¤ ìˆ˜ì • ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] ì‚¬ì—…ì¥ ì¶”ê°€/ì œê±° í…ŒìŠ¤íŠ¸
- [ ] ìˆœì„œ ë³€ê²½ (Drag & Drop) í…ŒìŠ¤íŠ¸

**ë°°í¬**
- [ ] Git ì»¤ë°‹ ë° í‘¸ì‹œ ì™„ë£Œ
- [ ] í”„ë¡œë•ì…˜ ì„œë²„ SSH ì ‘ì† í™•ì¸
- [ ] PM2 ìƒíƒœ í™•ì¸
- [ ] ë°°í¬ í›„ API Health Check

### 7.2 Phase 2 ë°°í¬ ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ë°±ì—”ë“œ**
- [ ] ë°°ì†¡ ê¸°ë¡ API í…ŒìŠ¤íŠ¸
- [ ] ì²´í¬ì¸/ì²´í¬ì•„ì›ƒ ë¡œì§ ê²€ì¦
- [ ] GPS ì¢Œí‘œ ì €ì¥ í™•ì¸

**ëª¨ë°”ì¼**
- [ ] Android ë¹Œë“œ ì„±ê³µ
- [ ] iOS ë¹Œë“œ ì„±ê³µ (Macì´ ìˆëŠ” ê²½ìš°)
- [ ] ìœ„ì¹˜ ê¶Œí•œ ìš”ì²­ ë™ì‘ í™•ì¸
- [ ] ì²´í¬ì¸/ì²´í¬ì•„ì›ƒ UI í…ŒìŠ¤íŠ¸
- [ ] ì˜¤í”„ë¼ì¸ ëŒ€ì‘ í™•ì¸

**í…ŒìŠ¤íŠ¸**
- [ ] ì‹¤ì œ ê¸°ê¸°ì—ì„œ GPS í…ŒìŠ¤íŠ¸
- [ ] ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠê¹€ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [ ] ë°°í„°ë¦¬ ì†Œëª¨ ëª¨ë‹ˆí„°ë§

### 7.3 Phase 3 ë°°í¬ ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ëª¨ë°”ì¼**
- [ ] ë°±ê·¸ë¼ìš´ë“œ ê¶Œí•œ ìš”ì²­ í™•ì¸
- [ ] Foreground Service ì•Œë¦¼ í‘œì‹œ í™•ì¸
- [ ] Geofencing ë™ì‘ í™•ì¸
- [ ] ë°°í„°ë¦¬ ìµœì í™” ì„¤ì • ì•ˆë‚´

**í…ŒìŠ¤íŠ¸**
- [ ] ì¥ì‹œê°„ (4ì‹œê°„+) ë°±ê·¸ë¼ìš´ë“œ ì¶”ì  í…ŒìŠ¤íŠ¸
- [ ] ì•± ì¢…ë£Œ í›„ì—ë„ ì¶”ì  ìœ ì§€ í™•ì¸
- [ ] ì‚¬ì—…ì¥ ë°˜ê²½ ì§„ì… ì‹œ ì•Œë¦¼ í™•ì¸

### 7.4 Phase 4 ë°°í¬ ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ë°±ì—”ë“œ**
- [ ] Kakao Mobility API í‚¤ ì„¤ì • í™•ì¸
- [ ] API í˜¸ì¶œ í•œë„ ëª¨ë‹ˆí„°ë§ ì„¤ì •
- [ ] ì—ëŸ¬ ì²˜ë¦¬ (API ì‹¤íŒ¨ ì‹œ)

**í”„ë¡ íŠ¸ì—”ë“œ**
- [ ] ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼ í‘œì‹œ í™•ì¸
- [ ] ìµœì í™” ê²°ê³¼ ì €ì¥ ê¸°ëŠ¥ í™•ì¸

**í…ŒìŠ¤íŠ¸**
- [ ] ì‹¤ì œ ì¢Œí‘œë¡œ ê²½ë¡œ ê³„ì‚° í…ŒìŠ¤íŠ¸
- [ ] API í˜¸ì¶œ íšŸìˆ˜ í™•ì¸ (ë¬´ë£Œ í•œë„ ë‚´)

### 7.5 ìµœì¢… ë°°í¬ ëª…ë ¹ì–´

```bash
# 1. ë¡œì»¬ì—ì„œ ìµœì¢… í…ŒìŠ¤íŠ¸
cd backend
npm run build
npm test

cd ../web
npm run build

cd ../mobile
npx expo doctor

# 2. Git ì»¤ë°‹
git add .
git commit -m "feat: Complete delivery route management system

Phase 1: Basic route management
Phase 2: Mobile delivery tracking
Phase 3: GPS auto-tracking
Phase 4: Route optimization

- Add 4 new database models
- Implement backend APIs
- Create web admin pages
- Build mobile delivery app
- Integrate Kakao Mobility API"

git push

# 3. í”„ë¡œë•ì…˜ ë°°í¬
ssh root@165.246.44.4
cd ~/daham_voc

# ë°±ì—…
pg_dump -U daham_user daham_voc > ~/backups/before_delivery_$(date +%Y%m%d).sql

# ë°°í¬
git pull
cd backend
npx prisma migrate deploy
npx prisma generate
npm install
npm run build
pm2 restart daham-voc-api

# 4. í™•ì¸
pm2 status
pm2 logs daham-voc-api --lines 50

# 5. API í…ŒìŠ¤íŠ¸
curl https://api.dahamvoc.co.kr/health

# 6. ëª¨ë°”ì¼ ì•± ë¹Œë“œ (EAS)
cd ~/daham_voc/mobile
eas build --platform android --profile production
```

---

## 8. ì°¸ê³  ìë£Œ

### 8.1 API ë¬¸ì„œ

**Kakao Mobility API**
- [ê¸¸ì°¾ê¸° API](https://developers.kakaomobility.com/docs/navi-api/directions/)
- [ì£¼ì†Œ ê²€ìƒ‰ API](https://developers.kakao.com/docs/latest/ko/local/dev-guide)

**Expo Location**
- [ê³µì‹ ë¬¸ì„œ](https://docs.expo.dev/versions/latest/sdk/location/)
- [Background Location](https://docs.expo.dev/versions/latest/sdk/task-manager/)

### 8.2 ë‚´ë¶€ ë¬¸ì„œ

- [ë°°ì†¡ì½”ìŠ¤_ì‹œìŠ¤í…œ_ê²€í† ì„œ.md](./ë°°ì†¡ì½”ìŠ¤_ì‹œìŠ¤í…œ_ê²€í† ì„œ.md) - ê¸°ìˆ  ê²€í†  ë° ë¶„ì„
- [êµ¬í˜„_ê°€ì´ë“œ_ë°°í¬_ì›Œí¬í”Œë¡œìš°.md](./êµ¬í˜„_ê°€ì´ë“œ_ë°°í¬_ì›Œí¬í”Œë¡œìš°.md) - ë°°í¬ í”„ë¡œì„¸ìŠ¤

### 8.3 íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

**ë¬¸ì œ: Kakao API 401 Unauthorized**
```bash
# .env íŒŒì¼ì— REST API í‚¤ í™•ì¸
echo $KAKAO_REST_API_KEY

# í”Œë«í¼ ë„ë©”ì¸ ë“±ë¡ í™•ì¸
# https://developers.kakao.com/console/app
```

**ë¬¸ì œ: ë°±ê·¸ë¼ìš´ë“œ ìœ„ì¹˜ ì¶”ì  ì¤‘ë‹¨**
```typescript
// Android: ë°°í„°ë¦¬ ìµœì í™” ì œì™¸ ìš”ì²­
import * as IntentLauncher from 'expo-intent-launcher';

await IntentLauncher.startActivityAsync(
  IntentLauncher.ActivityAction.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
);
```

**ë¬¸ì œ: Geofencing ë™ì‘ ì•ˆ í•¨**
```typescript
// iOS: Info.plistì— ê¶Œí•œ ì„¤ëª… ì¶”ê°€
<key>NSLocationAlwaysUsageDescription</key>
<string>ë°°ì†¡ ì¤‘ ìë™ ì²´í¬ì¸ì„ ìœ„í•´ ìœ„ì¹˜ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤</string>
```

---

**ì‘ì„± ì™„ë£Œì¼**: 2025-10-19
**ì‘ì„±ì**: Claude Code Assistant
**ì´ ì˜ˆìƒ ê°œë°œ ê¸°ê°„**: 26ì¼ (ì•½ 1ê°œì›”)
